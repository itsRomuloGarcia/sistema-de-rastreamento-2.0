"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/rastreio-ifood/page",{

/***/ "(app-pages-browser)/./hooks/use-tracking-cpf.ts":
/*!***********************************!*\
  !*** ./hooks/use-tracking-cpf.ts ***!
  \***********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getTrackingStatus: function() { return /* binding */ getTrackingStatus; },\n/* harmony export */   useSheetDataIfood: function() { return /* binding */ useSheetDataIfood; },\n/* harmony export */   useTrackingSearchCPF: function() { return /* binding */ useTrackingSearchCPF; }\n/* harmony export */ });\n/* harmony import */ var _tanstack_react_query__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tanstack/react-query */ \"(app-pages-browser)/./node_modules/@tanstack/react-query/build/modern/useQuery.js\");\n/* harmony import */ var xlsx__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! xlsx */ \"(app-pages-browser)/./node_modules/xlsx/xlsx.mjs\");\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n/* __next_internal_client_entry_do_not_use__ getTrackingStatus,useSheetDataIfood,useTrackingSearchCPF auto */ \n\nconst SHEET_URL_IFOOD = process.env.NEXT_PUBLIC_SHEET_URL_IFOOD || \"https://docs.google.com/spreadsheets/d/1A8rNGt2e0mxk124nN9sjkyvaek0O1kNmS-Pd8naggpM/edit?usp=sharing\";\nfunction parseDate(dateStr) {\n    if (!dateStr || dateStr === \"N/A\" || dateStr.trim() === \"\") return null;\n    try {\n        // Extrai dia, mês e ano diretamente\n        const [day, month, year] = dateStr.trim().split(\"/\").map(Number);\n        // Valida os valores\n        if (!day || !month || !year || day < 1 || day > 31 || month < 1 || month > 12) {\n            return null;\n        }\n        // Cria a data em UTC (ignora timezone completamente)\n        const parsed = new Date(Date.UTC(year, month - 1, day, 0, 0, 0, 0));\n        // Verificação rigorosa usando UTC\n        if (parsed.getUTCDate() === day && parsed.getUTCMonth() === month - 1 && parsed.getUTCFullYear() === year) {\n            return parsed;\n        }\n    } catch (error) {\n        console.warn(\"Erro ao fazer parse da data:\", dateStr, error);\n    }\n    return null;\n}\nfunction calculateDeliveryTime(startDate, endDate) {\n    const start = parseDate(startDate);\n    if (!start) return undefined;\n    const end = endDate ? parseDate(endDate) : new Date();\n    if (!end) return undefined;\n    // Calcula diferença em dias usando UTC\n    const startMidnight = Date.UTC(start.getUTCFullYear(), start.getUTCMonth(), start.getUTCDate());\n    const endMidnight = Date.UTC(end.getUTCFullYear(), end.getUTCMonth(), end.getUTCDate());\n    const diffTime = endMidnight - startMidnight;\n    const diffDays = Math.floor(diffTime / (1000 * 60 * 60 * 24));\n    return diffDays >= 0 ? diffDays : undefined;\n}\nfunction getTrackingStatus(data) {\n    const today = new Date();\n    const deliveryDate = data[\"Data de Entrega\"] ? parseDate(data[\"Data de Entrega\"]) : null;\n    const expectedDate = parseDate(data[\"Previsao de Entrega\"]);\n    if (deliveryDate) {\n        return {\n            status: \"delivered\",\n            label: \"Entregue\",\n            color: \"text-green-700 dark:text-green-400\",\n            bgColor: \"bg-green-100 dark:bg-green-900/30\"\n        };\n    }\n    if (expectedDate && today > expectedDate) {\n        return {\n            status: \"delayed\",\n            label: \"Atrasado\",\n            color: \"text-red-700 dark:text-red-400\",\n            bgColor: \"bg-red-100 dark:bg-red-900/30\"\n        };\n    }\n    const shippingDate = parseDate(data[\"Data de Envio\"]);\n    if (shippingDate) {\n        return {\n            status: \"shipped\",\n            label: \"Em Tr\\xe2nsito\",\n            color: \"text-blue-700 dark:text-blue-400\",\n            bgColor: \"bg-blue-100 dark:bg-blue-900/30\"\n        };\n    }\n    return {\n        status: \"pending\",\n        label: \"Processando\",\n        color: \"text-yellow-700 dark:text-yellow-400\",\n        bgColor: \"bg-yellow-100 dark:bg-yellow-900/30\"\n    };\n}\n// Mapeamento EXATO para a planilha iFood\nconst validateAndCleanDataIfood = (rawData)=>{\n    if (!Array.isArray(rawData)) {\n        console.warn(\"Dados iFood n\\xe3o s\\xe3o um array:\", rawData);\n        return [];\n    }\n    return rawData.filter((item)=>{\n        if (!item || typeof item !== \"object\") return false;\n        const hasCNPJ = item[\"CNPJ\"] && String(item[\"CNPJ\"]).trim() !== \"\";\n        return hasCNPJ;\n    }).map((item)=>{\n        try {\n            const cnpjClean = item[\"CNPJ\"] ? String(item[\"CNPJ\"]).replace(/\\D/g, \"\") : \"\";\n            const pedidoQepta = item[\"Qepta\"] && String(item[\"Qepta\"]).trim() !== \"\" ? Number(String(item[\"Qepta\"]).trim()) : 0;\n            // BUSCA COMPROVANTE NA COLUNA BN (NÃO EXCLUIR)\n            let comprovanteUrl = \"\";\n            // Tenta diferentes nomes possíveis para a coluna BN\n            const possiveisNomes = [\n                \"N\\xc3O EXCLUIR\",\n                \"N\\xc3O EXCLUIR \",\n                \"NAO EXCLUIR\"\n            ];\n            for (const nomeColuna of possiveisNomes){\n                if (item[nomeColuna] && String(item[nomeColuna]).trim().startsWith(\"http\")) {\n                    const link = String(item[nomeColuna]).trim();\n                    comprovanteUrl = link.replace(\"/view?\", \"/preview?\");\n                    console.log(\"✅ Link do comprovante encontrado:\", comprovanteUrl);\n                    break;\n                }\n            }\n            // Se não encontrou com os nomes padrão, busca qualquer coluna que comece com \"NÃO\"\n            if (!comprovanteUrl) {\n                const colunas = Object.keys(item);\n                const colunaBN = colunas.find((col)=>col.startsWith(\"N\\xc3O\") || col.startsWith(\"NAO\"));\n                if (colunaBN && item[colunaBN] && String(item[colunaBN]).trim().startsWith(\"http\")) {\n                    const link = String(item[colunaBN]).trim();\n                    comprovanteUrl = link.replace(\"/view?\", \"/preview?\");\n                    console.log(\"✅ Link encontrado na coluna:\", colunaBN, comprovanteUrl);\n                }\n            }\n            const tempoEntrega = calculateDeliveryTime(item[\"Data real de Sa\\xedda\"] || \"\", item[\"Data Real de Entrega totem (executada)\"] || \"\");\n            const result = {\n                Pedido: pedidoQepta,\n                QEPTA: pedidoQepta,\n                CNPJ: cnpjClean,\n                \"Data de Envio\": item[\"Data real de Sa\\xedda\"] ? String(item[\"Data real de Sa\\xedda\"]).trim() : \"N/A\",\n                \"Previsao de Entrega\": item[\"Data real da Previs\\xe3o de Entrega\"] ? String(item[\"Data real da Previs\\xe3o de Entrega\"]).trim() : \"N/A\",\n                \"Data de Entrega\": item[\"Data Real de Entrega totem (executada)\"] ? String(item[\"Data Real de Entrega totem (executada)\"]).trim() : undefined,\n                \"Nota Fiscal\": item[\"NF do Totem\"] ? Number(String(item[\"NF do Totem\"]).trim()) || 0 : 0,\n                Quantidade: item[\"Quantidade\"] ? Number(item[\"Quantidade\"]) || 1 : 1,\n                \"Tipo do Produto\": item[\"Modelo do totem\"] ? String(item[\"Modelo do totem\"]).trim() : \"N/A\",\n                Modelo: item[\"Modelo do totem\"] ? String(item[\"Modelo do totem\"]).trim() : \"N/A\",\n                Cidade: item[\"Cidade\"] ? String(item[\"Cidade\"]).trim() : \"N/A\",\n                Estado: item[\"Estado\"] ? String(item[\"Estado\"]).trim() : \"N/A\",\n                Transportadora: item[\"Transportadora\"] ? String(item[\"Transportadora\"]).trim() : \"N/A\",\n                Cliente: item[\"Raz\\xe3o Social\"] ? String(item[\"Raz\\xe3o Social\"]).trim() : \"N/A\",\n                \"Valor do Produto\": \"N/A\",\n                \"Valor do Transporte\": \"N/A\",\n                \"Comprovante URL\": comprovanteUrl,\n                \"Tempo de Entrega\": tempoEntrega,\n                \"Nome Fantasia\": item[\"Nome Fantasia\"] ? String(item[\"Nome Fantasia\"]).trim() : \"N/A\"\n            };\n            return result;\n        } catch (error) {\n            console.warn(\"❌ Erro ao processar item iFood:\", item, error);\n            return null;\n        }\n    }).filter((item)=>item !== null);\n};\nfunction useSheetDataIfood() {\n    return (0,_tanstack_react_query__WEBPACK_IMPORTED_MODULE_0__.useQuery)({\n        queryKey: [\n            \"sheet-data-ifood\"\n        ],\n        queryFn: async ()=>{\n            try {\n                if (!SHEET_URL_IFOOD) {\n                    throw new Error(\"URL da planilha iFood n\\xe3o configurada\");\n                }\n                console.log(\"\\uD83D\\uDD04 Buscando dados da planilha iFood...\");\n                const exportUrl = SHEET_URL_IFOOD.replace(\"/edit\", \"/export\").replace(\"?usp=sharing\", \"\") + \"?format=csv&gid=541004446\";\n                const response = await fetch(exportUrl, {\n                    headers: {\n                        \"Cache-Control\": \"no-cache\"\n                    }\n                });\n                if (!response.ok) {\n                    throw new Error(\"Erro HTTP iFood: \".concat(response.status));\n                }\n                const csvText = await response.text();\n                if (!csvText || csvText.trim() === \"\") {\n                    throw new Error(\"Planilha iFood vazia\");\n                }\n                const workbook = xlsx__WEBPACK_IMPORTED_MODULE_1__.read(csvText, {\n                    type: \"string\",\n                    raw: false,\n                    dateNF: \"dd/mm/yyyy\"\n                });\n                const sheetName = workbook.SheetNames.find((name)=>name.toLowerCase().includes(\"ifood\")) || workbook.SheetNames[0];\n                const worksheet = workbook.Sheets[sheetName];\n                const rawData = xlsx__WEBPACK_IMPORTED_MODULE_1__.utils.sheet_to_json(worksheet, {\n                    raw: false,\n                    defval: \"\"\n                });\n                // DEBUG: Mostrar colunas disponíveis\n                if (rawData.length > 0) {\n                    console.log(\"\\uD83D\\uDD0D COLUNAS DISPON\\xcdVEIS:\", Object.keys(rawData[0]));\n                }\n                const cleanData = validateAndCleanDataIfood(rawData);\n                console.log(\"✅ Dados iFood processados:\", cleanData.length, \"registros\");\n                return cleanData;\n            } catch (error) {\n                console.error(\"❌ Erro ao buscar dados iFood:\", error);\n                throw error;\n            }\n        },\n        refetchInterval: 30000,\n        staleTime: 10000,\n        retry: 2\n    });\n}\nfunction useTrackingSearchCPF(query) {\n    const { data: allData, ...rest } = useSheetDataIfood();\n    const trackingData = (allData === null || allData === void 0 ? void 0 : allData.filter((item)=>{\n        if (!item || !query) return false;\n        try {\n            const cnpjItem = item.CNPJ || \"\";\n            const queryClean = String(query).replace(/\\D/g, \"\").trim();\n            if (!queryClean) return false;\n            return cnpjItem === queryClean;\n        } catch (error) {\n            console.warn(\"Erro na busca iFood:\", error);\n            return false;\n        }\n    })) || [];\n    return {\n        data: trackingData,\n        ...rest\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2hvb2tzL3VzZS10cmFja2luZy1jcGYudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OzhHQUVnRDtBQUNwQjtBQUk1QixNQUFNRSxrQkFBa0JDLE9BQU9BLENBQUNDLEdBQUcsQ0FBQ0MsMkJBQTJCLElBQUk7QUErQm5FLFNBQVNDLFVBQVVDLE9BQWU7SUFDaEMsSUFBSSxDQUFDQSxXQUFXQSxZQUFZLFNBQVNBLFFBQVFDLElBQUksT0FBTyxJQUFJLE9BQU87SUFFbkUsSUFBSTtRQUNGLG9DQUFvQztRQUNwQyxNQUFNLENBQUNDLEtBQUtDLE9BQU9DLEtBQUssR0FBR0osUUFBUUMsSUFBSSxHQUFHSSxLQUFLLENBQUMsS0FBS0MsR0FBRyxDQUFDQztRQUV6RCxvQkFBb0I7UUFDcEIsSUFBSSxDQUFDTCxPQUFPLENBQUNDLFNBQVMsQ0FBQ0MsUUFBUUYsTUFBTSxLQUFLQSxNQUFNLE1BQU1DLFFBQVEsS0FBS0EsUUFBUSxJQUFJO1lBQzdFLE9BQU87UUFDVDtRQUVBLHFEQUFxRDtRQUNyRCxNQUFNSyxTQUFTLElBQUlDLEtBQUtBLEtBQUtDLEdBQUcsQ0FBQ04sTUFBTUQsUUFBUSxHQUFHRCxLQUFLLEdBQUcsR0FBRyxHQUFHO1FBRWhFLGtDQUFrQztRQUNsQyxJQUFJTSxPQUFPRyxVQUFVLE9BQU9ULE9BQ3hCTSxPQUFPSSxXQUFXLE9BQU9ULFFBQVEsS0FDakNLLE9BQU9LLGNBQWMsT0FBT1QsTUFBTTtZQUNwQyxPQUFPSTtRQUNUO0lBRUYsRUFBRSxPQUFPTSxPQUFPO1FBQ2RDLFFBQVFDLElBQUksQ0FBQyxnQ0FBZ0NoQixTQUFTYztJQUN4RDtJQUVBLE9BQU87QUFDVDtBQUVBLFNBQVNHLHNCQUFzQkMsU0FBaUIsRUFBRUMsT0FBZ0I7SUFDaEUsTUFBTUMsUUFBUXJCLFVBQVVtQjtJQUN4QixJQUFJLENBQUNFLE9BQU8sT0FBT0M7SUFFbkIsTUFBTUMsTUFBTUgsVUFBVXBCLFVBQVVvQixXQUFXLElBQUlWO0lBQy9DLElB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LENBQUMsaUNBQWlDQTtnQkFDL0MsTUFBTUE7WUFDUjtRQUVGO1FBQ0F1RixpQkFBaUI7UUFDakJDLFdBQVc7UUFDWEMsT0FBTztJQUNUO0FBQ0Y7QUFFTyxTQUFTQyxxQkFBcUJDLEtBQWE7SUFDaEQsTUFBTSxFQUFFM0UsTUFBTTRFLE9BQU8sRUFBRSxHQUFHQyxNQUFNLEdBQUdsQztJQUVuQyxNQUFNbUMsZUFBZUYsQ0FBQUEsb0JBQUFBLDhCQUFBQSxRQUFTL0QsTUFBTSxDQUFDQyxDQUFBQTtRQUNuQyxJQUFJLENBQUNBLFFBQVEsQ0FBQzZELE9BQU8sT0FBTztRQUU1QixJQUFJO1lBQ0YsTUFBTUksV0FBV2pFLEtBQUtzQixJQUFJLElBQUk7WUFDOUIsTUFBTTRDLGFBQWFoRSxPQUFPMkQsT0FBT3pELE9BQU8sQ0FBQyxPQUFPLElBQUkvQyxJQUFJO1lBRXhELElBQUksQ0FBQzZHLFlBQVksT0FBTztZQUV4QixPQUFPRCxhQUFhQztRQUN0QixFQUFFLE9BQU9oRyxPQUFPO1lBQ2RDLFFBQVFDLElBQUksQ0FBQyx3QkFBd0JGO1lBQ3JDLE9BQU87UUFDVDtJQUNGLE9BQU0sRUFBRTtJQUVSLE9BQU87UUFDTGdCLE1BQU04RTtRQUNOLEdBQUdELElBQUk7SUFDVDtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2hvb2tzL3VzZS10cmFja2luZy1jcGYudHM/Y2JmNyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCdcblxuaW1wb3J0IHsgdXNlUXVlcnkgfSBmcm9tICdAdGFuc3RhY2svcmVhY3QtcXVlcnknXG5pbXBvcnQgKiBhcyBYTFNYIGZyb20gJ3hsc3gnXG5pbXBvcnQgeyBUcmFja2luZ0RhdGEgfSBmcm9tICdAL3R5cGVzL3RyYWNraW5nJ1xuaW1wb3J0IHsgcGFyc2UsIHBhcnNlSVNPLCBpc1ZhbGlkLCBkaWZmZXJlbmNlSW5EYXlzIH0gZnJvbSAnZGF0ZS1mbnMnXG5cbmNvbnN0IFNIRUVUX1VSTF9JRk9PRCA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX1NIRUVUX1VSTF9JRk9PRCB8fCAnaHR0cHM6Ly9kb2NzLmdvb2dsZS5jb20vc3ByZWFkc2hlZXRzL2QvMUE4ck5HdDJlMG14azEyNG5OOXNqa3l2YWVrME8xa05tUy1QZDhuYWdncE0vZWRpdD91c3A9c2hhcmluZydcblxuLy8gSW50ZXJmYWNlIGVzcGVjw61maWNhIHBhcmEgaUZvb2RcbmV4cG9ydCBpbnRlcmZhY2UgVHJhY2tpbmdEYXRhSWZvb2QgZXh0ZW5kcyBUcmFja2luZ0RhdGEge1xuICAnQ29tcHJvdmFudGUgVVJMJz86IHN0cmluZ1xuICAnVGVtcG8gZGUgRW50cmVnYSc/OiBudW1iZXIgfCBudWxsXG59XG5cbi8vIEludGVyZmFjZSBwYXJhIG9zIGRhZG9zIGJydXRvcyBkYSBwbGFuaWxoYVxuaW50ZXJmYWNlIFNoZWV0Um93SWZvb2Qge1xuICAnU8Oqbmlvcic/OiBzdHJpbmcgfCBudW1iZXJcbiAgJ1FlcHRhJz86IHN0cmluZyB8IG51bWJlclxuICAnQ05QSic/OiBzdHJpbmdcbiAgJ0RhdGEgcmVhbCBkZSBTYcOtZGEnPzogc3RyaW5nXG4gICdEYXRhIHJlYWwgZGEgUHJldmlzw6NvIGRlIEVudHJlZ2EnPzogc3RyaW5nXG4gICdEYXRhIFJlYWwgZGUgRW50cmVnYSB0b3RlbSAoZXhlY3V0YWRhKSc/OiBzdHJpbmdcbiAgJ05GIGRvIFRvdGVtJz86IHN0cmluZyB8IG51bWJlclxuICAnUXVhbnRpZGFkZSc/OiBzdHJpbmcgfCBudW1iZXJcbiAgJ01vZGVsbyBkbyB0b3RlbSc/OiBzdHJpbmdcbiAgJ0NpZGFkZSc/OiBzdHJpbmdcbiAgJ0VzdGFkbyc/OiBzdHJpbmdcbiAgJ1RyYW5zcG9ydGFkb3JhJz86IHN0cmluZ1xuICAnUmF6w6NvIFNvY2lhbCc/OiBzdHJpbmdcbiAgJ05vbWUgRmFudGFzaWEnPzogc3RyaW5nXG4gICdDb21wcm92YW50ZSBkZSBlbnRyZWdhJz86IHN0cmluZ1xuICAnTsODTyBFWENMVUlSJz86IHN0cmluZ1xuICAnTsODTyBFWENMVUlSICc/OiBzdHJpbmdcbiAgJ05BTyBFWENMVUlSJz86IHN0cmluZ1xuICBba2V5OiBzdHJpbmddOiBhbnkgLy8gUGFyYSBvdXRyYXMgY29sdW5hcyBuw6NvIG1hcGVhZGFzXG59XG5cbmZ1bmN0aW9uIHBhcnNlRGF0ZShkYXRlU3RyOiBzdHJpbmcpOiBEYXRlIHwgbnVsbCB7XG4gIGlmICghZGF0ZVN0ciB8fCBkYXRlU3RyID09PSAnTi9BJyB8fCBkYXRlU3RyLnRyaW0oKSA9PT0gJycpIHJldHVybiBudWxsXG5cbiAgdHJ5IHtcbiAgICAvLyBFeHRyYWkgZGlhLCBtw6pzIGUgYW5vIGRpcmV0YW1lbnRlXG4gICAgY29uc3QgW2RheSwgbW9udGgsIHllYXJdID0gZGF0ZVN0ci50cmltKCkuc3BsaXQoJy8nKS5tYXAoTnVtYmVyKVxuICAgIFxuICAgIC8vIFZhbGlkYSBvcyB2YWxvcmVzXG4gICAgaWYgKCFkYXkgfHwgIW1vbnRoIHx8ICF5ZWFyIHx8IGRheSA8IDEgfHwgZGF5ID4gMzEgfHwgbW9udGggPCAxIHx8IG1vbnRoID4gMTIpIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuICAgIFxuICAgIC8vIENyaWEgYSBkYXRhIGVtIFVUQyAoaWdub3JhIHRpbWV6b25lIGNvbXBsZXRhbWVudGUpXG4gICAgY29uc3QgcGFyc2VkID0gbmV3IERhdGUoRGF0ZS5VVEMoeWVhciwgbW9udGggLSAxLCBkYXksIDAsIDAsIDAsIDApKVxuICAgIFxuICAgIC8vIFZlcmlmaWNhw6fDo28gcmlnb3Jvc2EgdXNhbmRvIFVUQ1xuICAgIGlmIChwYXJzZWQuZ2V0VVRDRGF0ZSgpID09PSBkYXkgJiYgXG4gICAgICAgIHBhcnNlZC5nZXRVVENNb250aCgpID09PSBtb250aCAtIDEgJiYgXG4gICAgICAgIHBhcnNlZC5nZXRVVENGdWxsWWVhcigpID09PSB5ZWFyKSB7XG4gICAgICByZXR1cm4gcGFyc2VkXG4gICAgfVxuICAgIFxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUud2FybignRXJybyBhbyBmYXplciBwYXJzZSBkYSBkYXRhOicsIGRhdGVTdHIsIGVycm9yKVxuICB9XG5cbiAgcmV0dXJuIG51bGxcbn1cblxuZnVuY3Rpb24gY2FsY3VsYXRlRGVsaXZlcnlUaW1lKHN0YXJ0RGF0ZTogc3RyaW5nLCBlbmREYXRlPzogc3RyaW5nKTogbnVtYmVyIHwgdW5kZWZpbmVkIHtcbiAgY29uc3Qgc3RhcnQgPSBwYXJzZURhdGUoc3RhcnREYXRlKVxuICBpZiAoIXN0YXJ0KSByZXR1cm4gdW5kZWZpbmVkXG5cbiAgY29uc3QgZW5kID0gZW5kRGF0ZSA/IHBhcnNlRGF0ZShlbmREYXRlKSA6IG5ldyBEYXRlKClcbiAgaWYgKCFlbmQpIHJldHVybiB1bmRlZmluZWRcblxuICAvLyBDYWxjdWxhIGRpZmVyZW7Dp2EgZW0gZGlhcyB1c2FuZG8gVVRDXG4gIGNvbnN0IHN0YXJ0TWlkbmlnaHQgPSBEYXRlLlVUQyhzdGFydC5nZXRVVENGdWxsWWVhcigpLCBzdGFydC5nZXRVVENNb250aCgpLCBzdGFydC5nZXRVVENEYXRlKCkpXG4gIGNvbnN0IGVuZE1pZG5pZ2h0ID0gRGF0ZS5VVEMoZW5kLmdldFVUQ0Z1bGxZZWFyKCksIGVuZC5nZXRVVENNb250aCgpLCBlbmQuZ2V0VVRDRGF0ZSgpKVxuICBcbiAgY29uc3QgZGlmZlRpbWUgPSBlbmRNaWRuaWdodCAtIHN0YXJ0TWlkbmlnaHRcbiAgY29uc3QgZGlmZkRheXMgPSBNYXRoLmZsb29yKGRpZmZUaW1lIC8gKDEwMDAgKiA2MCAqIDYwICogMjQpKVxuXG4gIHJldHVybiBkaWZmRGF5cyA+PSAwID8gZGlmZkRheXMgOiB1bmRlZmluZWRcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFRyYWNraW5nU3RhdHVzKGRhdGE6IFRyYWNraW5nRGF0YSkge1xuICBjb25zdCB0b2RheSA9IG5ldyBEYXRlKClcbiAgY29uc3QgZGVsaXZlcnlEYXRlID0gZGF0YVsnRGF0YSBkZSBFbnRyZWdhJ10gPyBwYXJzZURhdGUoZGF0YVsnRGF0YSBkZSBFbnRyZWdhJ10pIDogbnVsbFxuICBjb25zdCBleHBlY3RlZERhdGUgPSBwYXJzZURhdGUoZGF0YVsnUHJldmlzYW8gZGUgRW50cmVnYSddKVxuXG4gIGlmIChkZWxpdmVyeURhdGUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3RhdHVzOiAnZGVsaXZlcmVkJyBhcyBjb25zdCxcbiAgICAgIGxhYmVsOiAnRW50cmVndWUnLFxuICAgICAgY29sb3I6ICd0ZXh0LWdyZWVuLTcwMCBkYXJrOnRleHQtZ3JlZW4tNDAwJyxcbiAgICAgIGJnQ29sb3I6ICdiZy1ncmVlbi0xMDAgZGFyazpiZy1ncmVlbi05MDAvMzAnXG4gICAgfVxuICB9XG5cbiAgaWYgKGV4cGVjdGVkRGF0ZSAmJiB0b2RheSA+IGV4cGVjdGVkRGF0ZSkge1xuICAgIHJldHVybiB7XG4gICAgICBzdGF0dXM6ICdkZWxheWVkJyBhcyBjb25zdCxcbiAgICAgIGxhYmVsOiAnQXRyYXNhZG8nLFxuICAgICAgY29sb3I6ICd0ZXh0LXJlZC03MDAgZGFyazp0ZXh0LXJlZC00MDAnLFxuICAgICAgYmdDb2xvcjogJ2JnLXJlZC0xMDAgZGFyazpiZy1yZWQtOTAwLzMwJ1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHNoaXBwaW5nRGF0ZSA9IHBhcnNlRGF0ZShkYXRhWydEYXRhIGRlIEVudmlvJ10pXG4gIGlmIChzaGlwcGluZ0RhdGUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3RhdHVzOiAnc2hpcHBlZCcgYXMgY29uc3QsXG4gICAgICBsYWJlbDogJ0VtIFRyw6Juc2l0bycsXG4gICAgICBjb2xvcjogJ3RleHQtYmx1ZS03MDAgZGFyazp0ZXh0LWJsdWUtNDAwJyxcbiAgICAgIGJnQ29sb3I6ICdiZy1ibHVlLTEwMCBkYXJrOmJnLWJsdWUtOTAwLzMwJ1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgc3RhdHVzOiAncGVuZGluZycgYXMgY29uc3QsXG4gICAgbGFiZWw6ICdQcm9jZXNzYW5kbycsXG4gICAgY29sb3I6ICd0ZXh0LXllbGxvdy03MDAgZGFyazp0ZXh0LXllbGxvdy00MDAnLFxuICAgIGJnQ29sb3I6ICdiZy15ZWxsb3ctMTAwIGRhcms6YmcteWVsbG93LTkwMC8zMCdcbiAgfVxufVxuXG4vLyBNYXBlYW1lbnRvIEVYQVRPIHBhcmEgYSBwbGFuaWxoYSBpRm9vZFxuY29uc3QgdmFsaWRhdGVBbmRDbGVhbkRhdGFJZm9vZCA9IChyYXdEYXRhOiBhbnlbXSk6IFRyYWNraW5nRGF0YUlmb29kW10gPT4ge1xuICBpZiAoIUFycmF5LmlzQXJyYXkocmF3RGF0YSkpIHtcbiAgICBjb25zb2xlLndhcm4oJ0RhZG9zIGlGb29kIG7Do28gc8OjbyB1bSBhcnJheTonLCByYXdEYXRhKVxuICAgIHJldHVybiBbXVxuICB9XG5cbiAgcmV0dXJuIHJhd0RhdGFcbiAgICAuZmlsdGVyKChpdGVtOiBhbnkpID0+IHtcbiAgICAgIGlmICghaXRlbSB8fCB0eXBlb2YgaXRlbSAhPT0gJ29iamVjdCcpIHJldHVybiBmYWxzZVxuICAgICAgY29uc3QgaGFzQ05QSiA9IGl0ZW1bJ0NOUEonXSAmJiBTdHJpbmcoaXRlbVsnQ05QSiddKS50cmltKCkgIT09ICcnXG4gICAgICByZXR1cm4gaGFzQ05QSlxuICAgIH0pXG4gICAgLm1hcCgoaXRlbTogYW55KSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBjbnBqQ2xlYW4gPSBpdGVtWydDTlBKJ10gPyBTdHJpbmcoaXRlbVsnQ05QSiddKS5yZXBsYWNlKC9cXEQvZywgJycpIDogJydcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IHBlZGlkb1FlcHRhID0gaXRlbVsnUWVwdGEnXSAmJiBTdHJpbmcoaXRlbVsnUWVwdGEnXSkudHJpbSgpICE9PSAnJyBcbiAgICAgICAgICA/IE51bWJlcihTdHJpbmcoaXRlbVsnUWVwdGEnXSkudHJpbSgpKSBcbiAgICAgICAgICA6IDBcblxuICAgICAgICAvLyBCVVNDQSBDT01QUk9WQU5URSBOQSBDT0xVTkEgQk4gKE7Dg08gRVhDTFVJUilcbiAgICAgICAgbGV0IGNvbXByb3ZhbnRlVXJsID0gJydcbiAgICAgICAgXG4gICAgICAgIC8vIFRlbnRhIGRpZmVyZW50ZXMgbm9tZXMgcG9zc8OtdmVpcyBwYXJhIGEgY29sdW5hIEJOXG4gICAgICAgIGNvbnN0IHBvc3NpdmVpc05vbWVzID0gWydOw4NPIEVYQ0xVSVInLCAnTsODTyBFWENMVUlSICcsICdOQU8gRVhDTFVJUiddXG4gICAgICAgIFxuICAgICAgICBmb3IgKGNvbnN0IG5vbWVDb2x1bmEgb2YgcG9zc2l2ZWlzTm9tZXMpIHtcbiAgICAgICAgICBpZiAoaXRlbVtub21lQ29sdW5hXSAmJiBTdHJpbmcoaXRlbVtub21lQ29sdW5hXSkudHJpbSgpLnN0YXJ0c1dpdGgoJ2h0dHAnKSkge1xuICAgICAgICAgICAgY29uc3QgbGluayA9IFN0cmluZyhpdGVtW25vbWVDb2x1bmFdKS50cmltKClcbiAgICAgICAgICAgIGNvbXByb3ZhbnRlVXJsID0gbGluay5yZXBsYWNlKCcvdmlldz8nLCAnL3ByZXZpZXc/JylcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCfinIUgTGluayBkbyBjb21wcm92YW50ZSBlbmNvbnRyYWRvOicsIGNvbXByb3ZhbnRlVXJsKVxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIFNlIG7Do28gZW5jb250cm91IGNvbSBvcyBub21lcyBwYWRyw6NvLCBidXNjYSBxdWFscXVlciBjb2x1bmEgcXVlIGNvbWVjZSBjb20gXCJOw4NPXCJcbiAgICAgICAgaWYgKCFjb21wcm92YW50ZVVybCkge1xuICAgICAgICAgIGNvbnN0IGNvbHVuYXMgPSBPYmplY3Qua2V5cyhpdGVtIGFzIG9iamVjdClcbiAgICAgICAgICBjb25zdCBjb2x1bmFCTiA9IGNvbHVuYXMuZmluZChjb2wgPT4gY29sLnN0YXJ0c1dpdGgoJ07Dg08nKSB8fCBjb2wuc3RhcnRzV2l0aCgnTkFPJykpXG4gICAgICAgICAgaWYgKGNvbHVuYUJOICYmIGl0ZW1bY29sdW5hQk5dICYmIFN0cmluZyhpdGVtW2NvbHVuYUJOXSkudHJpbSgpLnN0YXJ0c1dpdGgoJ2h0dHAnKSkge1xuICAgICAgICAgICAgY29uc3QgbGluayA9IFN0cmluZyhpdGVtW2NvbHVuYUJOXSkudHJpbSgpXG4gICAgICAgICAgICBjb21wcm92YW50ZVVybCA9IGxpbmsucmVwbGFjZSgnL3ZpZXc/JywgJy9wcmV2aWV3PycpXG4gICAgICAgICAgICBjb25zb2xlLmxvZygn4pyFIExpbmsgZW5jb250cmFkbyBuYSBjb2x1bmE6JywgY29sdW5hQk4sIGNvbXByb3ZhbnRlVXJsKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHRlbXBvRW50cmVnYSA9IGNhbGN1bGF0ZURlbGl2ZXJ5VGltZShcbiAgICAgICAgICBpdGVtWydEYXRhIHJlYWwgZGUgU2HDrWRhJ10gfHwgJycsXG4gICAgICAgICAgaXRlbVsnRGF0YSBSZWFsIGRlIEVudHJlZ2EgdG90ZW0gKGV4ZWN1dGFkYSknXSB8fCAnJ1xuICAgICAgICApXG5cbiAgICAgICAgY29uc3QgcmVzdWx0OiBUcmFja2luZ0RhdGFJZm9vZCA9IHtcbiAgICAgICAgICBQZWRpZG86IHBlZGlkb1FlcHRhLFxuICAgICAgICAgIFFFUFRBOiBwZWRpZG9RZXB0YSxcbiAgICAgICAgICBDTlBKOiBjbnBqQ2xlYW4sXG4gICAgICAgICAgJ0RhdGEgZGUgRW52aW8nOiBpdGVtWydEYXRhIHJlYWwgZGUgU2HDrWRhJ10gPyBTdHJpbmcoaXRlbVsnRGF0YSByZWFsIGRlIFNhw61kYSddKS50cmltKCkgOiAnTi9BJyxcbiAgICAgICAgICAnUHJldmlzYW8gZGUgRW50cmVnYSc6IGl0ZW1bJ0RhdGEgcmVhbCBkYSBQcmV2aXPDo28gZGUgRW50cmVnYSddID8gU3RyaW5nKGl0ZW1bJ0RhdGEgcmVhbCBkYSBQcmV2aXPDo28gZGUgRW50cmVnYSddKS50cmltKCkgOiAnTi9BJyxcbiAgICAgICAgICAnRGF0YSBkZSBFbnRyZWdhJzogaXRlbVsnRGF0YSBSZWFsIGRlIEVudHJlZ2EgdG90ZW0gKGV4ZWN1dGFkYSknXSA/IFN0cmluZyhpdGVtWydEYXRhIFJlYWwgZGUgRW50cmVnYSB0b3RlbSAoZXhlY3V0YWRhKSddKS50cmltKCkgOiB1bmRlZmluZWQsXG4gICAgICAgICAgJ05vdGEgRmlzY2FsJzogaXRlbVsnTkYgZG8gVG90ZW0nXSA/IE51bWJlcihTdHJpbmcoaXRlbVsnTkYgZG8gVG90ZW0nXSkudHJpbSgpKSB8fCAwIDogMCxcbiAgICAgICAgICBRdWFudGlkYWRlOiBpdGVtWydRdWFudGlkYWRlJ10gPyBOdW1iZXIoaXRlbVsnUXVhbnRpZGFkZSddKSB8fCAxIDogMSxcbiAgICAgICAgICAnVGlwbyBkbyBQcm9kdXRvJzogaXRlbVsnTW9kZWxvIGRvIHRvdGVtJ10gPyBTdHJpbmcoaXRlbVsnTW9kZWxvIGRvIHRvdGVtJ10pLnRyaW0oKSA6ICdOL0EnLFxuICAgICAgICAgIE1vZGVsbzogaXRlbVsnTW9kZWxvIGRvIHRvdGVtJ10gPyBTdHJpbmcoaXRlbVsnTW9kZWxvIGRvIHRvdGVtJ10pLnRyaW0oKSA6ICdOL0EnLFxuICAgICAgICAgIENpZGFkZTogaXRlbVsnQ2lkYWRlJ10gPyBTdHJpbmcoaXRlbVsnQ2lkYWRlJ10pLnRyaW0oKSA6ICdOL0EnLFxuICAgICAgICAgIEVzdGFkbzogaXRlbVsnRXN0YWRvJ10gPyBTdHJpbmcoaXRlbVsnRXN0YWRvJ10pLnRyaW0oKSA6ICdOL0EnLFxuICAgICAgICAgIFRyYW5zcG9ydGFkb3JhOiBpdGVtWydUcmFuc3BvcnRhZG9yYSddID8gU3RyaW5nKGl0ZW1bJ1RyYW5zcG9ydGFkb3JhJ10pLnRyaW0oKSA6ICdOL0EnLFxuICAgICAgICAgIENsaWVudGU6IGl0ZW1bJ1JhesOjbyBTb2NpYWwnXSA/IFN0cmluZyhpdGVtWydSYXrDo28gU29jaWFsJ10pLnRyaW0oKSA6ICdOL0EnLFxuICAgICAgICAgICdWYWxvciBkbyBQcm9kdXRvJzogJ04vQScsXG4gICAgICAgICAgJ1ZhbG9yIGRvIFRyYW5zcG9ydGUnOiAnTi9BJyxcbiAgICAgICAgICAnQ29tcHJvdmFudGUgVVJMJzogY29tcHJvdmFudGVVcmwsXG4gICAgICAgICAgJ1RlbXBvIGRlIEVudHJlZ2EnOiB0ZW1wb0VudHJlZ2EsXG4gICAgICAgICAgJ05vbWUgRmFudGFzaWEnOiBpdGVtWydOb21lIEZhbnRhc2lhJ10gPyBTdHJpbmcoaXRlbVsnTm9tZSBGYW50YXNpYSddKS50cmltKCkgOiAnTi9BJ1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdFxuICAgICAgICBcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUud2Fybign4p2MIEVycm8gYW8gcHJvY2Vzc2FyIGl0ZW0gaUZvb2Q6JywgaXRlbSwgZXJyb3IpXG4gICAgICAgIHJldHVybiBudWxsXG4gICAgICB9XG4gICAgfSlcbiAgICAuZmlsdGVyKChpdGVtKTogaXRlbSBpcyBUcmFja2luZ0RhdGFJZm9vZCA9PiBpdGVtICE9PSBudWxsKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlU2hlZXREYXRhSWZvb2QoKSB7XG4gIHJldHVybiB1c2VRdWVyeSh7XG4gICAgcXVlcnlLZXk6IFsnc2hlZXQtZGF0YS1pZm9vZCddLFxuICAgIHF1ZXJ5Rm46IGFzeW5jICgpOiBQcm9taXNlPFRyYWNraW5nRGF0YUlmb29kW10+ID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICghU0hFRVRfVVJMX0lGT09EKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVUkwgZGEgcGxhbmlsaGEgaUZvb2QgbsOjbyBjb25maWd1cmFkYScpXG4gICAgICAgIH1cblxuICAgICAgICBjb25zb2xlLmxvZygn8J+UhCBCdXNjYW5kbyBkYWRvcyBkYSBwbGFuaWxoYSBpRm9vZC4uLicpXG5cbiAgICAgICAgY29uc3QgZXhwb3J0VXJsID0gU0hFRVRfVVJMX0lGT09EXG4gICAgICAgICAgLnJlcGxhY2UoJy9lZGl0JywgJy9leHBvcnQnKVxuICAgICAgICAgIC5yZXBsYWNlKCc/dXNwPXNoYXJpbmcnLCAnJylcbiAgICAgICAgICArICc/Zm9ybWF0PWNzdiZnaWQ9NTQxMDA0NDQ2J1xuXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goZXhwb3J0VXJsLCB7XG4gICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgJ0NhY2hlLUNvbnRyb2wnOiAnbm8tY2FjaGUnLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pXG5cbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRXJybyBIVFRQIGlGb29kOiAke3Jlc3BvbnNlLnN0YXR1c31gKVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgY3N2VGV4dCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKVxuXG4gICAgICAgIGlmICghY3N2VGV4dCB8fCBjc3ZUZXh0LnRyaW0oKSA9PT0gJycpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BsYW5pbGhhIGlGb29kIHZhemlhJylcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHdvcmtib29rID0gWExTWC5yZWFkKGNzdlRleHQsIHsgXG4gICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgcmF3OiBmYWxzZSxcbiAgICAgICAgICBkYXRlTkY6ICdkZC9tbS95eXl5J1xuICAgICAgICB9KVxuXG4gICAgICAgIGNvbnN0IHNoZWV0TmFtZSA9IHdvcmtib29rLlNoZWV0TmFtZXMuZmluZChuYW1lID0+IFxuICAgICAgICAgIG5hbWUudG9Mb3dlckNhc2UoKS5pbmNsdWRlcygnaWZvb2QnKVxuICAgICAgICApIHx8IHdvcmtib29rLlNoZWV0TmFtZXNbMF1cblxuICAgICAgICBjb25zdCB3b3Jrc2hlZXQgPSB3b3JrYm9vay5TaGVldHNbc2hlZXROYW1lXVxuICAgICAgICBjb25zdCByYXdEYXRhID0gWExTWC51dGlscy5zaGVldF90b19qc29uKHdvcmtzaGVldCwge1xuICAgICAgICAgIHJhdzogZmFsc2UsXG4gICAgICAgICAgZGVmdmFsOiAnJ1xuICAgICAgICB9KSBhcyBTaGVldFJvd0lmb29kW11cblxuICAgICAgICAvLyBERUJVRzogTW9zdHJhciBjb2x1bmFzIGRpc3BvbsOtdmVpc1xuICAgICAgICBpZiAocmF3RGF0YS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coJ/CflI0gQ09MVU5BUyBESVNQT07DjVZFSVM6JywgT2JqZWN0LmtleXMocmF3RGF0YVswXSkpXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjbGVhbkRhdGEgPSB2YWxpZGF0ZUFuZENsZWFuRGF0YUlmb29kKHJhd0RhdGEpXG4gICAgICAgIGNvbnNvbGUubG9nKCfinIUgRGFkb3MgaUZvb2QgcHJvY2Vzc2Fkb3M6JywgY2xlYW5EYXRhLmxlbmd0aCwgJ3JlZ2lzdHJvcycpXG5cbiAgICAgICAgcmV0dXJuIGNsZWFuRGF0YVxuXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCfinYwgRXJybyBhbyBidXNjYXIgZGFkb3MgaUZvb2Q6JywgZXJyb3IpXG4gICAgICAgIHRocm93IGVycm9yXG4gICAgICB9XG4gICAgICBcbiAgICB9LFxuICAgIHJlZmV0Y2hJbnRlcnZhbDogMzAwMDAsXG4gICAgc3RhbGVUaW1lOiAxMDAwMCxcbiAgICByZXRyeTogMixcbiAgfSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZVRyYWNraW5nU2VhcmNoQ1BGKHF1ZXJ5OiBzdHJpbmcpIHtcbiAgY29uc3QgeyBkYXRhOiBhbGxEYXRhLCAuLi5yZXN0IH0gPSB1c2VTaGVldERhdGFJZm9vZCgpXG5cbiAgY29uc3QgdHJhY2tpbmdEYXRhID0gYWxsRGF0YT8uZmlsdGVyKGl0ZW0gPT4ge1xuICAgIGlmICghaXRlbSB8fCAhcXVlcnkpIHJldHVybiBmYWxzZVxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGNucGpJdGVtID0gaXRlbS5DTlBKIHx8ICcnXG4gICAgICBjb25zdCBxdWVyeUNsZWFuID0gU3RyaW5nKHF1ZXJ5KS5yZXBsYWNlKC9cXEQvZywgJycpLnRyaW0oKVxuXG4gICAgICBpZiAoIXF1ZXJ5Q2xlYW4pIHJldHVybiBmYWxzZVxuXG4gICAgICByZXR1cm4gY25wakl0ZW0gPT09IHF1ZXJ5Q2xlYW5cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS53YXJuKCdFcnJvIG5hIGJ1c2NhIGlGb29kOicsIGVycm9yKVxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9KSB8fCBbXVxuXG4gIHJldHVybiB7XG4gICAgZGF0YTogdHJhY2tpbmdEYXRhLFxuICAgIC4uLnJlc3RcbiAgfVxufSJdLCJuYW1lcyI6WyJ1c2VRdWVyeSIsIlhMU1giLCJTSEVFVF9VUkxfSUZPT0QiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfU0hFRVRfVVJMX0lGT09EIiwicGFyc2VEYXRlIiwiZGF0ZVN0ciIsInRyaW0iLCJkYXkiLCJtb250aCIsInllYXIiLCJzcGxpdCIsIm1hcCIsIk51bWJlciIsInBhcnNlZCIsIkRhdGUiLCJVVEMiLCJnZXRVVENEYXRlIiwiZ2V0VVRDTW9udGgiLCJnZXRVVENGdWxsWWVhciIsImVycm9yIiwiY29uc29sZSIsIndhcm4iLCJjYWxjdWxhdGVEZWxpdmVyeVRpbWUiLCJzdGFydERhdGUiLCJlbmREYXRlIiwic3RhcnQiLCJ1bmRlZmluZWQiLCJlbmQiLCJzdGFydE1pZG5pZ2h0IiwiZW5kTWlkbmlnaHQiLCJkaWZmVGltZSIsImRpZmZEYXlzIiwiTWF0aCIsImZsb29yIiwiZ2V0VHJhY2tpbmdTdGF0dXMiLCJkYXRhIiwidG9kYXkiLCJkZWxpdmVyeURhdGUiLCJleHBlY3RlZERhdGUiLCJzdGF0dXMiLCJsYWJlbCIsImNvbG9yIiwiYmdDb2xvciIsInNoaXBwaW5nRGF0ZSIsInZhbGlkYXRlQW5kQ2xlYW5EYXRhSWZvb2QiLCJyYXdEYXRhIiwiQXJyYXkiLCJpc0FycmF5IiwiZmlsdGVyIiwiaXRlbSIsImhhc0NOUEoiLCJTdHJpbmciLCJjbnBqQ2xlYW4iLCJyZXBsYWNlIiwicGVkaWRvUWVwdGEiLCJjb21wcm92YW50ZVVybCIsInBvc3NpdmVpc05vbWVzIiwibm9tZUNvbHVuYSIsInN0YXJ0c1dpdGgiLCJsaW5rIiwibG9nIiwiY29sdW5hcyIsIk9iamVjdCIsImtleXMiLCJjb2x1bmFCTiIsImZpbmQiLCJjb2wiLCJ0ZW1wb0VudHJlZ2EiLCJyZXN1bHQiLCJQZWRpZG8iLCJRRVBUQSIsIkNOUEoiLCJRdWFudGlkYWRlIiwiTW9kZWxvIiwiQ2lkYWRlIiwiRXN0YWRvIiwiVHJhbnNwb3J0YWRvcmEiLCJDbGllbnRlIiwidXNlU2hlZXREYXRhSWZvb2QiLCJxdWVyeUtleSIsInF1ZXJ5Rm4iLCJFcnJvciIsImV4cG9ydFVybCIsInJlc3BvbnNlIiwiZmV0Y2giLCJoZWFkZXJzIiwib2siLCJjc3ZUZXh0IiwidGV4dCIsIndvcmtib29rIiwicmVhZCIsInR5cGUiLCJyYXciLCJkYXRlTkYiLCJzaGVldE5hbWUiLCJTaGVldE5hbWVzIiwibmFtZSIsInRvTG93ZXJDYXNlIiwiaW5jbHVkZXMiLCJ3b3Jrc2hlZXQiLCJTaGVldHMiLCJ1dGlscyIsInNoZWV0X3RvX2pzb24iLCJkZWZ2YWwiLCJsZW5ndGgiLCJjbGVhbkRhdGEiLCJyZWZldGNoSW50ZXJ2YWwiLCJzdGFsZVRpbWUiLCJyZXRyeSIsInVzZVRyYWNraW5nU2VhcmNoQ1BGIiwicXVlcnkiLCJhbGxEYXRhIiwicmVzdCIsInRyYWNraW5nRGF0YSIsImNucGpJdGVtIiwicXVlcnlDbGVhbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./hooks/use-tracking-cpf.ts\n"));

/***/ })

});