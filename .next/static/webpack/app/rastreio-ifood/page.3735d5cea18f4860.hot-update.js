"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/rastreio-ifood/page",{

/***/ "(app-pages-browser)/./hooks/use-tracking-cpf.ts":
/*!***********************************!*\
  !*** ./hooks/use-tracking-cpf.ts ***!
  \***********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getTrackingStatus: function() { return /* binding */ getTrackingStatus; },\n/* harmony export */   useSheetDataIfood: function() { return /* binding */ useSheetDataIfood; },\n/* harmony export */   useTrackingSearchCPF: function() { return /* binding */ useTrackingSearchCPF; }\n/* harmony export */ });\n/* harmony import */ var _tanstack_react_query__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tanstack/react-query */ \"(app-pages-browser)/./node_modules/@tanstack/react-query/build/modern/useQuery.js\");\n/* harmony import */ var xlsx__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! xlsx */ \"(app-pages-browser)/./node_modules/xlsx/xlsx.mjs\");\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n/* __next_internal_client_entry_do_not_use__ getTrackingStatus,useSheetDataIfood,useTrackingSearchCPF auto */ \n\nconst SHEET_URL_IFOOD = process.env.NEXT_PUBLIC_SHEET_URL_IFOOD || \"https://docs.google.com/spreadsheets/d/1A8rNGt2e0mxk124nN9sjkyvaek0O1kNmS-Pd8naggpM/edit?usp=sharing\";\nfunction parseDate(dateStr) {\n    if (!dateStr || dateStr === \"N/A\" || dateStr.trim() === \"\") return null;\n    try {\n        // Extrai dia, mês e ano diretamente\n        const [day, month, year] = dateStr.trim().split(\"/\").map(Number);\n        // Valida os valores\n        if (!day || !month || !year || day < 1 || day > 31 || month < 1 || month > 12) {\n            return null;\n        }\n        // Cria a data no fuso horário LOCAL (não UTC)\n        const parsed = new Date(year, month - 1, day, 0, 0, 0, 0);\n        // Verificação rigorosa usando horário local\n        if (parsed.getDate() === day && parsed.getMonth() === month - 1 && parsed.getFullYear() === year) {\n            return parsed;\n        }\n    } catch (error) {\n        console.warn(\"Erro ao fazer parse da data:\", dateStr, error);\n    }\n    return null;\n}\nfunction calculateDeliveryTime(startDate, endDate) {\n    const start = parseDate(startDate);\n    if (!start) return undefined;\n    const end = endDate ? parseDate(endDate) : new Date();\n    if (!end) return undefined;\n    // Calcula diferença em dias usando horário local\n    const startMidnight = new Date(start.getFullYear(), start.getMonth(), start.getDate()).getTime();\n    const endMidnight = new Date(end.getFullYear(), end.getMonth(), end.getDate()).getTime();\n    const diffTime = endMidnight - startMidnight;\n    const diffDays = Math.floor(diffTime / (1000 * 60 * 60 * 24));\n    return diffDays >= 0 ? diffDays : undefined;\n}\nfunction getTrackingStatus(data) {\n    const today = new Date();\n    const deliveryDate = data[\"Data de Entrega\"] ? parseDate(data[\"Data de Entrega\"]) : null;\n    const expectedDate = parseDate(data[\"Previsao de Entrega\"]);\n    if (deliveryDate) {\n        return {\n            status: \"delivered\",\n            label: \"Entregue\",\n            color: \"text-green-700 dark:text-green-400\",\n            bgColor: \"bg-green-100 dark:bg-green-900/30\"\n        };\n    }\n    if (expectedDate && today > expectedDate) {\n        return {\n            status: \"delayed\",\n            label: \"Atrasado\",\n            color: \"text-red-700 dark:text-red-400\",\n            bgColor: \"bg-red-100 dark:bg-red-900/30\"\n        };\n    }\n    const shippingDate = parseDate(data[\"Data de Envio\"]);\n    if (shippingDate) {\n        return {\n            status: \"shipped\",\n            label: \"Em Tr\\xe2nsito\",\n            color: \"text-blue-700 dark:text-blue-400\",\n            bgColor: \"bg-blue-100 dark:bg-blue-900/30\"\n        };\n    }\n    return {\n        status: \"pending\",\n        label: \"Processando\",\n        color: \"text-yellow-700 dark:text-yellow-400\",\n        bgColor: \"bg-yellow-100 dark:bg-yellow-900/30\"\n    };\n}\n// Mapeamento EXATO para a planilha iFood\nconst validateAndCleanDataIfood = (rawData)=>{\n    if (!Array.isArray(rawData)) {\n        console.warn(\"Dados iFood n\\xe3o s\\xe3o um array:\", rawData);\n        return [];\n    }\n    return rawData.filter((item)=>{\n        if (!item || typeof item !== \"object\") return false;\n        const hasCNPJ = item[\"CNPJ\"] && String(item[\"CNPJ\"]).trim() !== \"\";\n        return hasCNPJ;\n    }).map((item)=>{\n        try {\n            const cnpjClean = item[\"CNPJ\"] ? String(item[\"CNPJ\"]).replace(/\\D/g, \"\") : \"\";\n            const pedidoQepta = item[\"Qepta\"] && String(item[\"Qepta\"]).trim() !== \"\" ? Number(String(item[\"Qepta\"]).trim()) : 0;\n            // BUSCA COMPROVANTE NA COLUNA BN (NÃO EXCLUIR)\n            let comprovanteUrl = \"\";\n            // Tenta diferentes nomes possíveis para a coluna BN\n            const possiveisNomes = [\n                \"N\\xc3O EXCLUIR\",\n                \"N\\xc3O EXCLUIR \",\n                \"NAO EXCLUIR\"\n            ];\n            for (const nomeColuna of possiveisNomes){\n                if (item[nomeColuna] && String(item[nomeColuna]).trim().startsWith(\"http\")) {\n                    const link = String(item[nomeColuna]).trim();\n                    comprovanteUrl = link.replace(\"/view?\", \"/preview?\");\n                    console.log(\"✅ Link do comprovante encontrado:\", comprovanteUrl);\n                    break;\n                }\n            }\n            // Se não encontrou com os nomes padrão, busca qualquer coluna que comece com \"NÃO\"\n            if (!comprovanteUrl) {\n                const colunas = Object.keys(item);\n                const colunaBN = colunas.find((col)=>col.startsWith(\"N\\xc3O\") || col.startsWith(\"NAO\"));\n                if (colunaBN && item[colunaBN] && String(item[colunaBN]).trim().startsWith(\"http\")) {\n                    const link = String(item[colunaBN]).trim();\n                    comprovanteUrl = link.replace(\"/view?\", \"/preview?\");\n                    console.log(\"✅ Link encontrado na coluna:\", colunaBN, comprovanteUrl);\n                }\n            }\n            const tempoEntrega = calculateDeliveryTime(item[\"Data real de Sa\\xedda\"] || \"\", item[\"Data Real de Entrega totem (executada)\"] || \"\");\n            const result = {\n                Pedido: pedidoQepta,\n                QEPTA: pedidoQepta,\n                CNPJ: cnpjClean,\n                \"Data de Envio\": item[\"Data real de Sa\\xedda\"] ? String(item[\"Data real de Sa\\xedda\"]).trim() : \"N/A\",\n                \"Previsao de Entrega\": item[\"Data real da Previs\\xe3o de Entrega\"] ? String(item[\"Data real da Previs\\xe3o de Entrega\"]).trim() : \"N/A\",\n                \"Data de Entrega\": item[\"Data Real de Entrega totem (executada)\"] ? String(item[\"Data Real de Entrega totem (executada)\"]).trim() : undefined,\n                \"Nota Fiscal\": item[\"NF do Totem\"] ? Number(String(item[\"NF do Totem\"]).trim()) || 0 : 0,\n                Quantidade: item[\"Quantidade\"] ? Number(item[\"Quantidade\"]) || 1 : 1,\n                \"Tipo do Produto\": item[\"Modelo do totem\"] ? String(item[\"Modelo do totem\"]).trim() : \"N/A\",\n                Modelo: item[\"Modelo do totem\"] ? String(item[\"Modelo do totem\"]).trim() : \"N/A\",\n                Cidade: item[\"Cidade\"] ? String(item[\"Cidade\"]).trim() : \"N/A\",\n                Estado: item[\"Estado\"] ? String(item[\"Estado\"]).trim() : \"N/A\",\n                Transportadora: item[\"Transportadora\"] ? String(item[\"Transportadora\"]).trim() : \"N/A\",\n                Cliente: item[\"Raz\\xe3o Social\"] ? String(item[\"Raz\\xe3o Social\"]).trim() : \"N/A\",\n                \"Valor do Produto\": \"N/A\",\n                \"Valor do Transporte\": \"N/A\",\n                \"Comprovante URL\": comprovanteUrl,\n                \"Tempo de Entrega\": tempoEntrega,\n                \"Nome Fantasia\": item[\"Nome Fantasia\"] ? String(item[\"Nome Fantasia\"]).trim() : \"N/A\"\n            };\n            return result;\n        } catch (error) {\n            console.warn(\"❌ Erro ao processar item iFood:\", item, error);\n            return null;\n        }\n    }).filter((item)=>item !== null);\n};\nfunction useSheetDataIfood() {\n    return (0,_tanstack_react_query__WEBPACK_IMPORTED_MODULE_0__.useQuery)({\n        queryKey: [\n            \"sheet-data-ifood\"\n        ],\n        queryFn: async ()=>{\n            try {\n                if (!SHEET_URL_IFOOD) {\n                    throw new Error(\"URL da planilha iFood n\\xe3o configurada\");\n                }\n                console.log(\"\\uD83D\\uDD04 Buscando dados da planilha iFood...\");\n                const exportUrl = SHEET_URL_IFOOD.replace(\"/edit\", \"/export\").replace(\"?usp=sharing\", \"\") + \"?format=csv&gid=541004446\";\n                const response = await fetch(exportUrl, {\n                    headers: {\n                        \"Cache-Control\": \"no-cache\"\n                    }\n                });\n                if (!response.ok) {\n                    throw new Error(\"Erro HTTP iFood: \".concat(response.status));\n                }\n                const csvText = await response.text();\n                if (!csvText || csvText.trim() === \"\") {\n                    throw new Error(\"Planilha iFood vazia\");\n                }\n                const workbook = xlsx__WEBPACK_IMPORTED_MODULE_1__.read(csvText, {\n                    type: \"string\",\n                    raw: false,\n                    dateNF: \"dd/mm/yyyy\"\n                });\n                const sheetName = workbook.SheetNames.find((name)=>name.toLowerCase().includes(\"ifood\")) || workbook.SheetNames[0];\n                const worksheet = workbook.Sheets[sheetName];\n                const rawData = xlsx__WEBPACK_IMPORTED_MODULE_1__.utils.sheet_to_json(worksheet, {\n                    raw: false,\n                    defval: \"\"\n                });\n                // DEBUG: Mostrar colunas disponíveis\n                if (rawData.length > 0) {\n                    console.log(\"\\uD83D\\uDD0D COLUNAS DISPON\\xcdVEIS:\", Object.keys(rawData[0]));\n                }\n                const cleanData = validateAndCleanDataIfood(rawData);\n                console.log(\"✅ Dados iFood processados:\", cleanData.length, \"registros\");\n                return cleanData;\n            } catch (error) {\n                console.error(\"❌ Erro ao buscar dados iFood:\", error);\n                throw error;\n            }\n        },\n        refetchInterval: 30000,\n        staleTime: 10000,\n        retry: 2\n    });\n}\nfunction useTrackingSearchCPF(query) {\n    const { data: allData, ...rest } = useSheetDataIfood();\n    const trackingData = (allData === null || allData === void 0 ? void 0 : allData.filter((item)=>{\n        if (!item || !query) return false;\n        try {\n            const cnpjItem = item.CNPJ || \"\";\n            const queryClean = String(query).replace(/\\D/g, \"\").trim();\n            if (!queryClean) return false;\n            return cnpjItem === queryClean;\n        } catch (error) {\n            console.warn(\"Erro na busca iFood:\", error);\n            return false;\n        }\n    })) || [];\n    return {\n        data: trackingData,\n        ...rest\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2hvb2tzL3VzZS10cmFja2luZy1jcGYudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OzhHQUVnRDtBQUNwQjtBQUk1QixNQUFNRSxrQkFBa0JDLE9BQU9BLENBQUNDLEdBQUcsQ0FBQ0MsMkJBQTJCLElBQUk7QUErQm5FLFNBQVNDLFVBQVVDLE9BQWU7SUFDaEMsSUFBSSxDQUFDQSxXQUFXQSxZQUFZLFNBQVNBLFFBQVFDLElBQUksT0FBTyxJQUFJLE9BQU87SUFFbkUsSUFBSTtRQUNGLG9DQUFvQztRQUNwQyxNQUFNLENBQUNDLEtBQUtDLE9BQU9DLEtBQUssR0FBR0osUUFBUUMsSUFBSSxHQUFHSSxLQUFLLENBQUMsS0FBS0MsR0FBRyxDQUFDQztRQUV6RCxvQkFBb0I7UUFDcEIsSUFBSSxDQUFDTCxPQUFPLENBQUNDLFNBQVMsQ0FBQ0MsUUFBUUYsTUFBTSxLQUFLQSxNQUFNLE1BQU1DLFFBQVEsS0FBS0EsUUFBUSxJQUFJO1lBQzdFLE9BQU87UUFDVDtRQUVBLDhDQUE4QztRQUM5QyxNQUFNSyxTQUFTLElBQUlDLEtBQUtMLE1BQU1ELFFBQVEsR0FBR0QsS0FBSyxHQUFHLEdBQUcsR0FBRztRQUV2RCw0Q0FBNEM7UUFDNUMsSUFBSU0sT0FBT0UsT0FBTyxPQUFPUixPQUNyQk0sT0FBT0csUUFBUSxPQUFPUixRQUFRLEtBQzlCSyxPQUFPSSxXQUFXLE9BQU9SLE1BQU07WUFDakMsT0FBT0k7UUFDVDtJQUVGLEVBQUUsT0FBT0ssT0FBTztRQUNkQyxRQUFRQyxJQUFJLENBQUMsZ0NBQWdDZixTQUFTYTtJQUN4RDtJQUVBLE9BQU87QUFDVDtBQUVBLFNBQVNHLHNCQUFzQkMsU0FBaUIsRUFBRUMsT0FBZ0I7SUFDaEUsTUFBTUMsUUFBUXBCLFVBQVVrQjtJQUN4QixJQUFJLENBQUNFLE9BQU8sT0FBT0M7SUFFbkIsTUFBTUMsTUFBTUgsVUFBVW5CLFVBQVVtQixXQUFXLElBQUlUO0lBQy9DLElBQUksQ0FBQ1ksS0FBSyxPQUFP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QUFpQ0E7Z0JBQy9DLE1BQU1BO1lBQ1I7UUFFRjtRQUNBd0YsaUJBQWlCO1FBQ2pCQyxXQUFXO1FBQ1hDLE9BQU87SUFDVDtBQUNGO0FBRU8sU0FBU0MscUJBQXFCQyxLQUFhO0lBQ2hELE1BQU0sRUFBRTNFLE1BQU00RSxPQUFPLEVBQUUsR0FBR0MsTUFBTSxHQUFHbEM7SUFFbkMsTUFBTW1DLGVBQWVGLENBQUFBLG9CQUFBQSw4QkFBQUEsUUFBUy9ELE1BQU0sQ0FBQ0MsQ0FBQUE7UUFDbkMsSUFBSSxDQUFDQSxRQUFRLENBQUM2RCxPQUFPLE9BQU87UUFFNUIsSUFBSTtZQUNGLE1BQU1JLFdBQVdqRSxLQUFLc0IsSUFBSSxJQUFJO1lBQzlCLE1BQU00QyxhQUFhaEUsT0FBTzJELE9BQU96RCxPQUFPLENBQUMsT0FBTyxJQUFJL0MsSUFBSTtZQUV4RCxJQUFJLENBQUM2RyxZQUFZLE9BQU87WUFFeEIsT0FBT0QsYUFBYUM7UUFDdEIsRUFBRSxPQUFPakcsT0FBTztZQUNkQyxRQUFRQyxJQUFJLENBQUMsd0JBQXdCRjtZQUNyQyxPQUFPO1FBQ1Q7SUFDRixPQUFNLEVBQUU7SUFFUixPQUFPO1FBQ0xpQixNQUFNOEU7UUFDTixHQUFHRCxJQUFJO0lBQ1Q7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ob29rcy91c2UtdHJhY2tpbmctY3BmLnRzP2NiZjciXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnXG5cbmltcG9ydCB7IHVzZVF1ZXJ5IH0gZnJvbSAnQHRhbnN0YWNrL3JlYWN0LXF1ZXJ5J1xuaW1wb3J0ICogYXMgWExTWCBmcm9tICd4bHN4J1xuaW1wb3J0IHsgVHJhY2tpbmdEYXRhIH0gZnJvbSAnQC90eXBlcy90cmFja2luZydcbmltcG9ydCB7IHBhcnNlLCBwYXJzZUlTTywgaXNWYWxpZCwgZGlmZmVyZW5jZUluRGF5cyB9IGZyb20gJ2RhdGUtZm5zJ1xuXG5jb25zdCBTSEVFVF9VUkxfSUZPT0QgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19TSEVFVF9VUkxfSUZPT0QgfHwgJ2h0dHBzOi8vZG9jcy5nb29nbGUuY29tL3NwcmVhZHNoZWV0cy9kLzFBOHJOR3QyZTBteGsxMjRuTjlzamt5dmFlazBPMWtObVMtUGQ4bmFnZ3BNL2VkaXQ/dXNwPXNoYXJpbmcnXG5cbi8vIEludGVyZmFjZSBlc3BlY8OtZmljYSBwYXJhIGlGb29kXG5leHBvcnQgaW50ZXJmYWNlIFRyYWNraW5nRGF0YUlmb29kIGV4dGVuZHMgVHJhY2tpbmdEYXRhIHtcbiAgJ0NvbXByb3ZhbnRlIFVSTCc/OiBzdHJpbmdcbiAgJ1RlbXBvIGRlIEVudHJlZ2EnPzogbnVtYmVyIHwgbnVsbFxufVxuXG4vLyBJbnRlcmZhY2UgcGFyYSBvcyBkYWRvcyBicnV0b3MgZGEgcGxhbmlsaGFcbmludGVyZmFjZSBTaGVldFJvd0lmb29kIHtcbiAgJ1PDqm5pb3InPzogc3RyaW5nIHwgbnVtYmVyXG4gICdRZXB0YSc/OiBzdHJpbmcgfCBudW1iZXJcbiAgJ0NOUEonPzogc3RyaW5nXG4gICdEYXRhIHJlYWwgZGUgU2HDrWRhJz86IHN0cmluZ1xuICAnRGF0YSByZWFsIGRhIFByZXZpc8OjbyBkZSBFbnRyZWdhJz86IHN0cmluZ1xuICAnRGF0YSBSZWFsIGRlIEVudHJlZ2EgdG90ZW0gKGV4ZWN1dGFkYSknPzogc3RyaW5nXG4gICdORiBkbyBUb3RlbSc/OiBzdHJpbmcgfCBudW1iZXJcbiAgJ1F1YW50aWRhZGUnPzogc3RyaW5nIHwgbnVtYmVyXG4gICdNb2RlbG8gZG8gdG90ZW0nPzogc3RyaW5nXG4gICdDaWRhZGUnPzogc3RyaW5nXG4gICdFc3RhZG8nPzogc3RyaW5nXG4gICdUcmFuc3BvcnRhZG9yYSc/OiBzdHJpbmdcbiAgJ1JhesOjbyBTb2NpYWwnPzogc3RyaW5nXG4gICdOb21lIEZhbnRhc2lhJz86IHN0cmluZ1xuICAnQ29tcHJvdmFudGUgZGUgZW50cmVnYSc/OiBzdHJpbmdcbiAgJ07Dg08gRVhDTFVJUic/OiBzdHJpbmdcbiAgJ07Dg08gRVhDTFVJUiAnPzogc3RyaW5nXG4gICdOQU8gRVhDTFVJUic/OiBzdHJpbmdcbiAgW2tleTogc3RyaW5nXTogYW55IC8vIFBhcmEgb3V0cmFzIGNvbHVuYXMgbsOjbyBtYXBlYWRhc1xufVxuXG5mdW5jdGlvbiBwYXJzZURhdGUoZGF0ZVN0cjogc3RyaW5nKTogRGF0ZSB8IG51bGwge1xuICBpZiAoIWRhdGVTdHIgfHwgZGF0ZVN0ciA9PT0gJ04vQScgfHwgZGF0ZVN0ci50cmltKCkgPT09ICcnKSByZXR1cm4gbnVsbFxuXG4gIHRyeSB7XG4gICAgLy8gRXh0cmFpIGRpYSwgbcOqcyBlIGFubyBkaXJldGFtZW50ZVxuICAgIGNvbnN0IFtkYXksIG1vbnRoLCB5ZWFyXSA9IGRhdGVTdHIudHJpbSgpLnNwbGl0KCcvJykubWFwKE51bWJlcilcbiAgICBcbiAgICAvLyBWYWxpZGEgb3MgdmFsb3Jlc1xuICAgIGlmICghZGF5IHx8ICFtb250aCB8fCAheWVhciB8fCBkYXkgPCAxIHx8IGRheSA+IDMxIHx8IG1vbnRoIDwgMSB8fCBtb250aCA+IDEyKSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cbiAgICBcbiAgICAvLyBDcmlhIGEgZGF0YSBubyBmdXNvIGhvcsOhcmlvIExPQ0FMIChuw6NvIFVUQylcbiAgICBjb25zdCBwYXJzZWQgPSBuZXcgRGF0ZSh5ZWFyLCBtb250aCAtIDEsIGRheSwgMCwgMCwgMCwgMClcbiAgICBcbiAgICAvLyBWZXJpZmljYcOnw6NvIHJpZ29yb3NhIHVzYW5kbyBob3LDoXJpbyBsb2NhbFxuICAgIGlmIChwYXJzZWQuZ2V0RGF0ZSgpID09PSBkYXkgJiYgXG4gICAgICAgIHBhcnNlZC5nZXRNb250aCgpID09PSBtb250aCAtIDEgJiYgXG4gICAgICAgIHBhcnNlZC5nZXRGdWxsWWVhcigpID09PSB5ZWFyKSB7XG4gICAgICByZXR1cm4gcGFyc2VkXG4gICAgfVxuICAgIFxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUud2FybignRXJybyBhbyBmYXplciBwYXJzZSBkYSBkYXRhOicsIGRhdGVTdHIsIGVycm9yKVxuICB9XG5cbiAgcmV0dXJuIG51bGxcbn1cblxuZnVuY3Rpb24gY2FsY3VsYXRlRGVsaXZlcnlUaW1lKHN0YXJ0RGF0ZTogc3RyaW5nLCBlbmREYXRlPzogc3RyaW5nKTogbnVtYmVyIHwgdW5kZWZpbmVkIHtcbiAgY29uc3Qgc3RhcnQgPSBwYXJzZURhdGUoc3RhcnREYXRlKVxuICBpZiAoIXN0YXJ0KSByZXR1cm4gdW5kZWZpbmVkXG5cbiAgY29uc3QgZW5kID0gZW5kRGF0ZSA/IHBhcnNlRGF0ZShlbmREYXRlKSA6IG5ldyBEYXRlKClcbiAgaWYgKCFlbmQpIHJldHVybiB1bmRlZmluZWRcblxuICAvLyBDYWxjdWxhIGRpZmVyZW7Dp2EgZW0gZGlhcyB1c2FuZG8gaG9yw6FyaW8gbG9jYWxcbiAgY29uc3Qgc3RhcnRNaWRuaWdodCA9IG5ldyBEYXRlKHN0YXJ0LmdldEZ1bGxZZWFyKCksIHN0YXJ0LmdldE1vbnRoKCksIHN0YXJ0LmdldERhdGUoKSkuZ2V0VGltZSgpXG4gIGNvbnN0IGVuZE1pZG5pZ2h0ID0gbmV3IERhdGUoZW5kLmdldEZ1bGxZZWFyKCksIGVuZC5nZXRNb250aCgpLCBlbmQuZ2V0RGF0ZSgpKS5nZXRUaW1lKClcbiAgXG4gIGNvbnN0IGRpZmZUaW1lID0gZW5kTWlkbmlnaHQgLSBzdGFydE1pZG5pZ2h0XG4gIGNvbnN0IGRpZmZEYXlzID0gTWF0aC5mbG9vcihkaWZmVGltZSAvICgxMDAwICogNjAgKiA2MCAqIDI0KSlcblxuICByZXR1cm4gZGlmZkRheXMgPj0gMCA/IGRpZmZEYXlzIDogdW5kZWZpbmVkXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRUcmFja2luZ1N0YXR1cyhkYXRhOiBUcmFja2luZ0RhdGEpIHtcbiAgY29uc3QgdG9kYXkgPSBuZXcgRGF0ZSgpXG4gIGNvbnN0IGRlbGl2ZXJ5RGF0ZSA9IGRhdGFbJ0RhdGEgZGUgRW50cmVnYSddID8gcGFyc2VEYXRlKGRhdGFbJ0RhdGEgZGUgRW50cmVnYSddKSA6IG51bGxcbiAgY29uc3QgZXhwZWN0ZWREYXRlID0gcGFyc2VEYXRlKGRhdGFbJ1ByZXZpc2FvIGRlIEVudHJlZ2EnXSlcblxuICBpZiAoZGVsaXZlcnlEYXRlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXR1czogJ2RlbGl2ZXJlZCcgYXMgY29uc3QsXG4gICAgICBsYWJlbDogJ0VudHJlZ3VlJyxcbiAgICAgIGNvbG9yOiAndGV4dC1ncmVlbi03MDAgZGFyazp0ZXh0LWdyZWVuLTQwMCcsXG4gICAgICBiZ0NvbG9yOiAnYmctZ3JlZW4tMTAwIGRhcms6YmctZ3JlZW4tOTAwLzMwJ1xuICAgIH1cbiAgfVxuXG4gIGlmIChleHBlY3RlZERhdGUgJiYgdG9kYXkgPiBleHBlY3RlZERhdGUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3RhdHVzOiAnZGVsYXllZCcgYXMgY29uc3QsXG4gICAgICBsYWJlbDogJ0F0cmFzYWRvJyxcbiAgICAgIGNvbG9yOiAndGV4dC1yZWQtNzAwIGRhcms6dGV4dC1yZWQtNDAwJyxcbiAgICAgIGJnQ29sb3I6ICdiZy1yZWQtMTAwIGRhcms6YmctcmVkLTkwMC8zMCdcbiAgICB9XG4gIH1cblxuICBjb25zdCBzaGlwcGluZ0RhdGUgPSBwYXJzZURhdGUoZGF0YVsnRGF0YSBkZSBFbnZpbyddKVxuICBpZiAoc2hpcHBpbmdEYXRlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXR1czogJ3NoaXBwZWQnIGFzIGNvbnN0LFxuICAgICAgbGFiZWw6ICdFbSBUcsOibnNpdG8nLFxuICAgICAgY29sb3I6ICd0ZXh0LWJsdWUtNzAwIGRhcms6dGV4dC1ibHVlLTQwMCcsXG4gICAgICBiZ0NvbG9yOiAnYmctYmx1ZS0xMDAgZGFyazpiZy1ibHVlLTkwMC8zMCdcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHN0YXR1czogJ3BlbmRpbmcnIGFzIGNvbnN0LFxuICAgIGxhYmVsOiAnUHJvY2Vzc2FuZG8nLFxuICAgIGNvbG9yOiAndGV4dC15ZWxsb3ctNzAwIGRhcms6dGV4dC15ZWxsb3ctNDAwJyxcbiAgICBiZ0NvbG9yOiAnYmcteWVsbG93LTEwMCBkYXJrOmJnLXllbGxvdy05MDAvMzAnXG4gIH1cbn1cblxuLy8gTWFwZWFtZW50byBFWEFUTyBwYXJhIGEgcGxhbmlsaGEgaUZvb2RcbmNvbnN0IHZhbGlkYXRlQW5kQ2xlYW5EYXRhSWZvb2QgPSAocmF3RGF0YTogYW55W10pOiBUcmFja2luZ0RhdGFJZm9vZFtdID0+IHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KHJhd0RhdGEpKSB7XG4gICAgY29uc29sZS53YXJuKCdEYWRvcyBpRm9vZCBuw6NvIHPDo28gdW0gYXJyYXk6JywgcmF3RGF0YSlcbiAgICByZXR1cm4gW11cbiAgfVxuXG4gIHJldHVybiByYXdEYXRhXG4gICAgLmZpbHRlcigoaXRlbTogYW55KSA9PiB7XG4gICAgICBpZiAoIWl0ZW0gfHwgdHlwZW9mIGl0ZW0gIT09ICdvYmplY3QnKSByZXR1cm4gZmFsc2VcbiAgICAgIGNvbnN0IGhhc0NOUEogPSBpdGVtWydDTlBKJ10gJiYgU3RyaW5nKGl0ZW1bJ0NOUEonXSkudHJpbSgpICE9PSAnJ1xuICAgICAgcmV0dXJuIGhhc0NOUEpcbiAgICB9KVxuICAgIC5tYXAoKGl0ZW06IGFueSkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgY25wakNsZWFuID0gaXRlbVsnQ05QSiddID8gU3RyaW5nKGl0ZW1bJ0NOUEonXSkucmVwbGFjZSgvXFxEL2csICcnKSA6ICcnXG4gICAgICAgIFxuICAgICAgICBjb25zdCBwZWRpZG9RZXB0YSA9IGl0ZW1bJ1FlcHRhJ10gJiYgU3RyaW5nKGl0ZW1bJ1FlcHRhJ10pLnRyaW0oKSAhPT0gJycgXG4gICAgICAgICAgPyBOdW1iZXIoU3RyaW5nKGl0ZW1bJ1FlcHRhJ10pLnRyaW0oKSkgXG4gICAgICAgICAgOiAwXG5cbiAgICAgICAgLy8gQlVTQ0EgQ09NUFJPVkFOVEUgTkEgQ09MVU5BIEJOIChOw4NPIEVYQ0xVSVIpXG4gICAgICAgIGxldCBjb21wcm92YW50ZVVybCA9ICcnXG4gICAgICAgIFxuICAgICAgICAvLyBUZW50YSBkaWZlcmVudGVzIG5vbWVzIHBvc3PDrXZlaXMgcGFyYSBhIGNvbHVuYSBCTlxuICAgICAgICBjb25zdCBwb3NzaXZlaXNOb21lcyA9IFsnTsODTyBFWENMVUlSJywgJ07Dg08gRVhDTFVJUiAnLCAnTkFPIEVYQ0xVSVInXVxuICAgICAgICBcbiAgICAgICAgZm9yIChjb25zdCBub21lQ29sdW5hIG9mIHBvc3NpdmVpc05vbWVzKSB7XG4gICAgICAgICAgaWYgKGl0ZW1bbm9tZUNvbHVuYV0gJiYgU3RyaW5nKGl0ZW1bbm9tZUNvbHVuYV0pLnRyaW0oKS5zdGFydHNXaXRoKCdodHRwJykpIHtcbiAgICAgICAgICAgIGNvbnN0IGxpbmsgPSBTdHJpbmcoaXRlbVtub21lQ29sdW5hXSkudHJpbSgpXG4gICAgICAgICAgICBjb21wcm92YW50ZVVybCA9IGxpbmsucmVwbGFjZSgnL3ZpZXc/JywgJy9wcmV2aWV3PycpXG4gICAgICAgICAgICBjb25zb2xlLmxvZygn4pyFIExpbmsgZG8gY29tcHJvdmFudGUgZW5jb250cmFkbzonLCBjb21wcm92YW50ZVVybClcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBTZSBuw6NvIGVuY29udHJvdSBjb20gb3Mgbm9tZXMgcGFkcsOjbywgYnVzY2EgcXVhbHF1ZXIgY29sdW5hIHF1ZSBjb21lY2UgY29tIFwiTsODT1wiXG4gICAgICAgIGlmICghY29tcHJvdmFudGVVcmwpIHtcbiAgICAgICAgICBjb25zdCBjb2x1bmFzID0gT2JqZWN0LmtleXMoaXRlbSBhcyBvYmplY3QpXG4gICAgICAgICAgY29uc3QgY29sdW5hQk4gPSBjb2x1bmFzLmZpbmQoY29sID0+IGNvbC5zdGFydHNXaXRoKCdOw4NPJykgfHwgY29sLnN0YXJ0c1dpdGgoJ05BTycpKVxuICAgICAgICAgIGlmIChjb2x1bmFCTiAmJiBpdGVtW2NvbHVuYUJOXSAmJiBTdHJpbmcoaXRlbVtjb2x1bmFCTl0pLnRyaW0oKS5zdGFydHNXaXRoKCdodHRwJykpIHtcbiAgICAgICAgICAgIGNvbnN0IGxpbmsgPSBTdHJpbmcoaXRlbVtjb2x1bmFCTl0pLnRyaW0oKVxuICAgICAgICAgICAgY29tcHJvdmFudGVVcmwgPSBsaW5rLnJlcGxhY2UoJy92aWV3PycsICcvcHJldmlldz8nKVxuICAgICAgICAgICAgY29uc29sZS5sb2coJ+KchSBMaW5rIGVuY29udHJhZG8gbmEgY29sdW5hOicsIGNvbHVuYUJOLCBjb21wcm92YW50ZVVybClcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB0ZW1wb0VudHJlZ2EgPSBjYWxjdWxhdGVEZWxpdmVyeVRpbWUoXG4gICAgICAgICAgaXRlbVsnRGF0YSByZWFsIGRlIFNhw61kYSddIHx8ICcnLFxuICAgICAgICAgIGl0ZW1bJ0RhdGEgUmVhbCBkZSBFbnRyZWdhIHRvdGVtIChleGVjdXRhZGEpJ10gfHwgJydcbiAgICAgICAgKVxuXG4gICAgICAgIGNvbnN0IHJlc3VsdDogVHJhY2tpbmdEYXRhSWZvb2QgPSB7XG4gICAgICAgICAgUGVkaWRvOiBwZWRpZG9RZXB0YSxcbiAgICAgICAgICBRRVBUQTogcGVkaWRvUWVwdGEsXG4gICAgICAgICAgQ05QSjogY25wakNsZWFuLFxuICAgICAgICAgICdEYXRhIGRlIEVudmlvJzogaXRlbVsnRGF0YSByZWFsIGRlIFNhw61kYSddID8gU3RyaW5nKGl0ZW1bJ0RhdGEgcmVhbCBkZSBTYcOtZGEnXSkudHJpbSgpIDogJ04vQScsXG4gICAgICAgICAgJ1ByZXZpc2FvIGRlIEVudHJlZ2EnOiBpdGVtWydEYXRhIHJlYWwgZGEgUHJldmlzw6NvIGRlIEVudHJlZ2EnXSA/IFN0cmluZyhpdGVtWydEYXRhIHJlYWwgZGEgUHJldmlzw6NvIGRlIEVudHJlZ2EnXSkudHJpbSgpIDogJ04vQScsXG4gICAgICAgICAgJ0RhdGEgZGUgRW50cmVnYSc6IGl0ZW1bJ0RhdGEgUmVhbCBkZSBFbnRyZWdhIHRvdGVtIChleGVjdXRhZGEpJ10gPyBTdHJpbmcoaXRlbVsnRGF0YSBSZWFsIGRlIEVudHJlZ2EgdG90ZW0gKGV4ZWN1dGFkYSknXSkudHJpbSgpIDogdW5kZWZpbmVkLFxuICAgICAgICAgICdOb3RhIEZpc2NhbCc6IGl0ZW1bJ05GIGRvIFRvdGVtJ10gPyBOdW1iZXIoU3RyaW5nKGl0ZW1bJ05GIGRvIFRvdGVtJ10pLnRyaW0oKSkgfHwgMCA6IDAsXG4gICAgICAgICAgUXVhbnRpZGFkZTogaXRlbVsnUXVhbnRpZGFkZSddID8gTnVtYmVyKGl0ZW1bJ1F1YW50aWRhZGUnXSkgfHwgMSA6IDEsXG4gICAgICAgICAgJ1RpcG8gZG8gUHJvZHV0byc6IGl0ZW1bJ01vZGVsbyBkbyB0b3RlbSddID8gU3RyaW5nKGl0ZW1bJ01vZGVsbyBkbyB0b3RlbSddKS50cmltKCkgOiAnTi9BJyxcbiAgICAgICAgICBNb2RlbG86IGl0ZW1bJ01vZGVsbyBkbyB0b3RlbSddID8gU3RyaW5nKGl0ZW1bJ01vZGVsbyBkbyB0b3RlbSddKS50cmltKCkgOiAnTi9BJyxcbiAgICAgICAgICBDaWRhZGU6IGl0ZW1bJ0NpZGFkZSddID8gU3RyaW5nKGl0ZW1bJ0NpZGFkZSddKS50cmltKCkgOiAnTi9BJyxcbiAgICAgICAgICBFc3RhZG86IGl0ZW1bJ0VzdGFkbyddID8gU3RyaW5nKGl0ZW1bJ0VzdGFkbyddKS50cmltKCkgOiAnTi9BJyxcbiAgICAgICAgICBUcmFuc3BvcnRhZG9yYTogaXRlbVsnVHJhbnNwb3J0YWRvcmEnXSA/IFN0cmluZyhpdGVtWydUcmFuc3BvcnRhZG9yYSddKS50cmltKCkgOiAnTi9BJyxcbiAgICAgICAgICBDbGllbnRlOiBpdGVtWydSYXrDo28gU29jaWFsJ10gPyBTdHJpbmcoaXRlbVsnUmF6w6NvIFNvY2lhbCddKS50cmltKCkgOiAnTi9BJyxcbiAgICAgICAgICAnVmFsb3IgZG8gUHJvZHV0byc6ICdOL0EnLFxuICAgICAgICAgICdWYWxvciBkbyBUcmFuc3BvcnRlJzogJ04vQScsXG4gICAgICAgICAgJ0NvbXByb3ZhbnRlIFVSTCc6IGNvbXByb3ZhbnRlVXJsLFxuICAgICAgICAgICdUZW1wbyBkZSBFbnRyZWdhJzogdGVtcG9FbnRyZWdhLFxuICAgICAgICAgICdOb21lIEZhbnRhc2lhJzogaXRlbVsnTm9tZSBGYW50YXNpYSddID8gU3RyaW5nKGl0ZW1bJ05vbWUgRmFudGFzaWEnXSkudHJpbSgpIDogJ04vQSdcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHRcblxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCfinYwgRXJybyBhbyBwcm9jZXNzYXIgaXRlbSBpRm9vZDonLCBpdGVtLCBlcnJvcilcbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgIH1cbiAgICB9KVxuICAgIC5maWx0ZXIoKGl0ZW0pOiBpdGVtIGlzIFRyYWNraW5nRGF0YUlmb29kID0+IGl0ZW0gIT09IG51bGwpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VTaGVldERhdGFJZm9vZCgpIHtcbiAgcmV0dXJuIHVzZVF1ZXJ5KHtcbiAgICBxdWVyeUtleTogWydzaGVldC1kYXRhLWlmb29kJ10sXG4gICAgcXVlcnlGbjogYXN5bmMgKCk6IFByb21pc2U8VHJhY2tpbmdEYXRhSWZvb2RbXT4gPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKCFTSEVFVF9VUkxfSUZPT0QpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VSTCBkYSBwbGFuaWxoYSBpRm9vZCBuw6NvIGNvbmZpZ3VyYWRhJylcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnNvbGUubG9nKCfwn5SEIEJ1c2NhbmRvIGRhZG9zIGRhIHBsYW5pbGhhIGlGb29kLi4uJylcblxuICAgICAgICBjb25zdCBleHBvcnRVcmwgPSBTSEVFVF9VUkxfSUZPT0RcbiAgICAgICAgICAucmVwbGFjZSgnL2VkaXQnLCAnL2V4cG9ydCcpXG4gICAgICAgICAgLnJlcGxhY2UoJz91c3A9c2hhcmluZycsICcnKVxuICAgICAgICAgICsgJz9mb3JtYXQ9Y3N2JmdpZD01NDEwMDQ0NDYnXG5cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChleHBvcnRVcmwsIHtcbiAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAnQ2FjaGUtQ29udHJvbCc6ICduby1jYWNoZScsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSlcblxuICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvIEhUVFAgaUZvb2Q6ICR7cmVzcG9uc2Uuc3RhdHVzfWApXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjc3ZUZXh0ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpXG5cbiAgICAgICAgaWYgKCFjc3ZUZXh0IHx8IGNzdlRleHQudHJpbSgpID09PSAnJykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUGxhbmlsaGEgaUZvb2QgdmF6aWEnKVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgd29ya2Jvb2sgPSBYTFNYLnJlYWQoY3N2VGV4dCwgeyBcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICByYXc6IGZhbHNlLFxuICAgICAgICAgIGRhdGVORjogJ2RkL21tL3l5eXknXG4gICAgICAgIH0pXG5cbiAgICAgICAgY29uc3Qgc2hlZXROYW1lID0gd29ya2Jvb2suU2hlZXROYW1lcy5maW5kKG5hbWUgPT4gXG4gICAgICAgICAgbmFtZS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKCdpZm9vZCcpXG4gICAgICAgICkgfHwgd29ya2Jvb2suU2hlZXROYW1lc1swXVxuXG4gICAgICAgIGNvbnN0IHdvcmtzaGVldCA9IHdvcmtib29rLlNoZWV0c1tzaGVldE5hbWVdXG4gICAgICAgIGNvbnN0IHJhd0RhdGEgPSBYTFNYLnV0aWxzLnNoZWV0X3RvX2pzb24od29ya3NoZWV0LCB7XG4gICAgICAgICAgcmF3OiBmYWxzZSxcbiAgICAgICAgICBkZWZ2YWw6ICcnXG4gICAgICAgIH0pIGFzIFNoZWV0Um93SWZvb2RbXVxuXG4gICAgICAgIC8vIERFQlVHOiBNb3N0cmFyIGNvbHVuYXMgZGlzcG9uw612ZWlzXG4gICAgICAgIGlmIChyYXdEYXRhLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBjb25zb2xlLmxvZygn8J+UjSBDT0xVTkFTIERJU1BPTsONVkVJUzonLCBPYmplY3Qua2V5cyhyYXdEYXRhWzBdKSlcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNsZWFuRGF0YSA9IHZhbGlkYXRlQW5kQ2xlYW5EYXRhSWZvb2QocmF3RGF0YSlcbiAgICAgICAgY29uc29sZS5sb2coJ+KchSBEYWRvcyBpRm9vZCBwcm9jZXNzYWRvczonLCBjbGVhbkRhdGEubGVuZ3RoLCAncmVnaXN0cm9zJylcblxuICAgICAgICByZXR1cm4gY2xlYW5EYXRhXG5cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBFcnJvIGFvIGJ1c2NhciBkYWRvcyBpRm9vZDonLCBlcnJvcilcbiAgICAgICAgdGhyb3cgZXJyb3JcbiAgICAgIH1cbiAgICAgIFxuICAgIH0sXG4gICAgcmVmZXRjaEludGVydmFsOiAzMDAwMCxcbiAgICBzdGFsZVRpbWU6IDEwMDAwLFxuICAgIHJldHJ5OiAyLFxuICB9KVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlVHJhY2tpbmdTZWFyY2hDUEYocXVlcnk6IHN0cmluZykge1xuICBjb25zdCB7IGRhdGE6IGFsbERhdGEsIC4uLnJlc3QgfSA9IHVzZVNoZWV0RGF0YUlmb29kKClcblxuICBjb25zdCB0cmFja2luZ0RhdGEgPSBhbGxEYXRhPy5maWx0ZXIoaXRlbSA9PiB7XG4gICAgaWYgKCFpdGVtIHx8ICFxdWVyeSkgcmV0dXJuIGZhbHNlXG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgY25wakl0ZW0gPSBpdGVtLkNOUEogfHwgJydcbiAgICAgIGNvbnN0IHF1ZXJ5Q2xlYW4gPSBTdHJpbmcocXVlcnkpLnJlcGxhY2UoL1xcRC9nLCAnJykudHJpbSgpXG5cbiAgICAgIGlmICghcXVlcnlDbGVhbikgcmV0dXJuIGZhbHNlXG5cbiAgICAgIHJldHVybiBjbnBqSXRlbSA9PT0gcXVlcnlDbGVhblxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ0Vycm8gbmEgYnVzY2EgaUZvb2Q6JywgZXJyb3IpXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH0pIHx8IFtdXG5cbiAgcmV0dXJuIHtcbiAgICBkYXRhOiB0cmFja2luZ0RhdGEsXG4gICAgLi4ucmVzdFxuICB9XG59Il0sIm5hbWVzIjpbInVzZVF1ZXJ5IiwiWExTWCIsIlNIRUVUX1VSTF9JRk9PRCIsInByb2Nlc3MiLCJlbnYiLCJORVhUX1BVQkxJQ19TSEVFVF9VUkxfSUZPT0QiLCJwYXJzZURhdGUiLCJkYXRlU3RyIiwidHJpbSIsImRheSIsIm1vbnRoIiwieWVhciIsInNwbGl0IiwibWFwIiwiTnVtYmVyIiwicGFyc2VkIiwiRGF0ZSIsImdldERhdGUiLCJnZXRNb250aCIsImdldEZ1bGxZZWFyIiwiZXJyb3IiLCJjb25zb2xlIiwid2FybiIsImNhbGN1bGF0ZURlbGl2ZXJ5VGltZSIsInN0YXJ0RGF0ZSIsImVuZERhdGUiLCJzdGFydCIsInVuZGVmaW5lZCIsImVuZCIsInN0YXJ0TWlkbmlnaHQiLCJnZXRUaW1lIiwiZW5kTWlkbmlnaHQiLCJkaWZmVGltZSIsImRpZmZEYXlzIiwiTWF0aCIsImZsb29yIiwiZ2V0VHJhY2tpbmdTdGF0dXMiLCJkYXRhIiwidG9kYXkiLCJkZWxpdmVyeURhdGUiLCJleHBlY3RlZERhdGUiLCJzdGF0dXMiLCJsYWJlbCIsImNvbG9yIiwiYmdDb2xvciIsInNoaXBwaW5nRGF0ZSIsInZhbGlkYXRlQW5kQ2xlYW5EYXRhSWZvb2QiLCJyYXdEYXRhIiwiQXJyYXkiLCJpc0FycmF5IiwiZmlsdGVyIiwiaXRlbSIsImhhc0NOUEoiLCJTdHJpbmciLCJjbnBqQ2xlYW4iLCJyZXBsYWNlIiwicGVkaWRvUWVwdGEiLCJjb21wcm92YW50ZVVybCIsInBvc3NpdmVpc05vbWVzIiwibm9tZUNvbHVuYSIsInN0YXJ0c1dpdGgiLCJsaW5rIiwibG9nIiwiY29sdW5hcyIsIk9iamVjdCIsImtleXMiLCJjb2x1bmFCTiIsImZpbmQiLCJjb2wiLCJ0ZW1wb0VudHJlZ2EiLCJyZXN1bHQiLCJQZWRpZG8iLCJRRVBUQSIsIkNOUEoiLCJRdWFudGlkYWRlIiwiTW9kZWxvIiwiQ2lkYWRlIiwiRXN0YWRvIiwiVHJhbnNwb3J0YWRvcmEiLCJDbGllbnRlIiwidXNlU2hlZXREYXRhSWZvb2QiLCJxdWVyeUtleSIsInF1ZXJ5Rm4iLCJFcnJvciIsImV4cG9ydFVybCIsInJlc3BvbnNlIiwiZmV0Y2giLCJoZWFkZXJzIiwib2siLCJjc3ZUZXh0IiwidGV4dCIsIndvcmtib29rIiwicmVhZCIsInR5cGUiLCJyYXciLCJkYXRlTkYiLCJzaGVldE5hbWUiLCJTaGVldE5hbWVzIiwibmFtZSIsInRvTG93ZXJDYXNlIiwiaW5jbHVkZXMiLCJ3b3Jrc2hlZXQiLCJTaGVldHMiLCJ1dGlscyIsInNoZWV0X3RvX2pzb24iLCJkZWZ2YWwiLCJsZW5ndGgiLCJjbGVhbkRhdGEiLCJyZWZldGNoSW50ZXJ2YWwiLCJzdGFsZVRpbWUiLCJyZXRyeSIsInVzZVRyYWNraW5nU2VhcmNoQ1BGIiwicXVlcnkiLCJhbGxEYXRhIiwicmVzdCIsInRyYWNraW5nRGF0YSIsImNucGpJdGVtIiwicXVlcnlDbGVhbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./hooks/use-tracking-cpf.ts\n"));

/***/ })

});