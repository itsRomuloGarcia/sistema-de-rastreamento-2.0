"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/rastreio-ifood/page",{

/***/ "(app-pages-browser)/./hooks/use-tracking-cpf.ts":
/*!***********************************!*\
  !*** ./hooks/use-tracking-cpf.ts ***!
  \***********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getTrackingStatus: function() { return /* binding */ getTrackingStatus; },\n/* harmony export */   useSheetDataIfood: function() { return /* binding */ useSheetDataIfood; },\n/* harmony export */   useTrackingSearchCPF: function() { return /* binding */ useTrackingSearchCPF; }\n/* harmony export */ });\n/* harmony import */ var _tanstack_react_query__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tanstack/react-query */ \"(app-pages-browser)/./node_modules/@tanstack/react-query/build/modern/useQuery.js\");\n/* harmony import */ var xlsx__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! xlsx */ \"(app-pages-browser)/./node_modules/xlsx/xlsx.mjs\");\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n/* __next_internal_client_entry_do_not_use__ getTrackingStatus,useSheetDataIfood,useTrackingSearchCPF auto */ \n\nconst SHEET_URL_IFOOD = process.env.NEXT_PUBLIC_SHEET_URL_IFOOD || \"https://docs.google.com/spreadsheets/d/1A8rNGt2e0mxk124nN9sjkyvaek0O1kNmS-Pd8naggpM/edit?usp=sharing\";\nfunction parseDate(dateStr) {\n    if (!dateStr || dateStr === \"N/A\" || typeof dateStr === \"string\" && dateStr.trim() === \"\") return null;\n    try {\n        // Se for número (serial date do Excel)\n        if (typeof dateStr === \"number\") {\n            // Converte serial date do Excel para data JavaScript\n            const excelEpoch = new Date(1899, 11, 30) // 30 de dezembro de 1899\n            ;\n            const date = new Date(excelEpoch.getTime() + dateStr * 86400000);\n            return date;\n        }\n        // Se for string no formato dd/mm/yyyy\n        const dateString = String(dateStr).trim();\n        const [day, month, year] = dateString.split(\"/\").map(Number);\n        // Valida os valores\n        if (!day || !month || !year || day < 1 || day > 31 || month < 1 || month > 12) {\n            return null;\n        }\n        // Cria a data às 12h para evitar problemas de timezone\n        const parsed = new Date(year, month - 1, day, 12, 0, 0, 0);\n        // Verificação rigorosa\n        if (parsed.getDate() === day && parsed.getMonth() === month - 1 && parsed.getFullYear() === year) {\n            return parsed;\n        }\n    } catch (error) {\n        console.warn(\"Erro ao fazer parse da data:\", dateStr, error);\n    }\n    return null;\n}\nfunction calculateDeliveryTime(startDate, endDate) {\n    const start = parseDate(startDate);\n    if (!start) return undefined;\n    const end = endDate ? parseDate(endDate) : new Date();\n    if (!end) return undefined;\n    // Calcula diferença em dias usando horário local\n    const startMidnight = new Date(start.getFullYear(), start.getMonth(), start.getDate()).getTime();\n    const endMidnight = new Date(end.getFullYear(), end.getMonth(), end.getDate()).getTime();\n    const diffTime = endMidnight - startMidnight;\n    const diffDays = Math.floor(diffTime / (1000 * 60 * 60 * 24));\n    return diffDays >= 0 ? diffDays : undefined;\n}\nfunction getTrackingStatus(data) {\n    const today = new Date();\n    const deliveryDate = data[\"Data de Entrega\"] ? parseDate(data[\"Data de Entrega\"]) : null;\n    const expectedDate = parseDate(data[\"Previsao de Entrega\"]);\n    if (deliveryDate) {\n        return {\n            status: \"delivered\",\n            label: \"Entregue\",\n            color: \"text-green-700 dark:text-green-400\",\n            bgColor: \"bg-green-100 dark:bg-green-900/30\"\n        };\n    }\n    if (expectedDate && today > expectedDate) {\n        return {\n            status: \"delayed\",\n            label: \"Atrasado\",\n            color: \"text-red-700 dark:text-red-400\",\n            bgColor: \"bg-red-100 dark:bg-red-900/30\"\n        };\n    }\n    const shippingDate = parseDate(data[\"Data de Envio\"]);\n    if (shippingDate) {\n        return {\n            status: \"shipped\",\n            label: \"Em Tr\\xe2nsito\",\n            color: \"text-blue-700 dark:text-blue-400\",\n            bgColor: \"bg-blue-100 dark:bg-blue-900/30\"\n        };\n    }\n    return {\n        status: \"pending\",\n        label: \"Processando\",\n        color: \"text-yellow-700 dark:text-yellow-400\",\n        bgColor: \"bg-yellow-100 dark:bg-yellow-900/30\"\n    };\n}\n// Mapeamento EXATO para a planilha iFood\nconst validateAndCleanDataIfood = (rawData)=>{\n    if (!Array.isArray(rawData)) {\n        console.warn(\"Dados iFood n\\xe3o s\\xe3o um array:\", rawData);\n        return [];\n    }\n    return rawData.filter((item)=>{\n        if (!item || typeof item !== \"object\") return false;\n        const hasCNPJ = item[\"CNPJ\"] && String(item[\"CNPJ\"]).trim() !== \"\";\n        return hasCNPJ;\n    }).map((item)=>{\n        try {\n            const cnpjClean = item[\"CNPJ\"] ? String(item[\"CNPJ\"]).replace(/\\D/g, \"\") : \"\";\n            const pedidoQepta = item[\"Qepta\"] && String(item[\"Qepta\"]).trim() !== \"\" ? Number(String(item[\"Qepta\"]).trim()) : 0;\n            // BUSCA COMPROVANTE NA COLUNA BN (NÃO EXCLUIR)\n            let comprovanteUrl = \"\";\n            // Tenta diferentes nomes possíveis para a coluna BN\n            const possiveisNomes = [\n                \"N\\xc3O EXCLUIR\",\n                \"N\\xc3O EXCLUIR \",\n                \"NAO EXCLUIR\"\n            ];\n            for (const nomeColuna of possiveisNomes){\n                if (item[nomeColuna] && String(item[nomeColuna]).trim().startsWith(\"http\")) {\n                    const link = String(item[nomeColuna]).trim();\n                    comprovanteUrl = link.replace(\"/view?\", \"/preview?\");\n                    console.log(\"✅ Link do comprovante encontrado:\", comprovanteUrl);\n                    break;\n                }\n            }\n            // Se não encontrou com os nomes padrão, busca qualquer coluna que comece com \"NÃO\"\n            if (!comprovanteUrl) {\n                const colunas = Object.keys(item);\n                const colunaBN = colunas.find((col)=>col.startsWith(\"N\\xc3O\") || col.startsWith(\"NAO\"));\n                if (colunaBN && item[colunaBN] && String(item[colunaBN]).trim().startsWith(\"http\")) {\n                    const link = String(item[colunaBN]).trim();\n                    comprovanteUrl = link.replace(\"/view?\", \"/preview?\");\n                    console.log(\"✅ Link encontrado na coluna:\", colunaBN, comprovanteUrl);\n                }\n            }\n            const tempoEntrega = calculateDeliveryTime(item[\"Data real de Sa\\xedda\"] || \"\", item[\"Data Real de Entrega totem (executada)\"] || \"\");\n            const result = {\n                Pedido: pedidoQepta,\n                QEPTA: pedidoQepta,\n                CNPJ: cnpjClean,\n                \"Data de Envio\": item[\"Data real de Sa\\xedda\"] ? String(item[\"Data real de Sa\\xedda\"]).trim() : \"N/A\",\n                \"Previsao de Entrega\": item[\"Data real da Previs\\xe3o de Entrega\"] ? String(item[\"Data real da Previs\\xe3o de Entrega\"]).trim() : \"N/A\",\n                \"Data de Entrega\": item[\"Data Real de Entrega totem (executada)\"] ? String(item[\"Data Real de Entrega totem (executada)\"]).trim() : undefined,\n                \"Nota Fiscal\": item[\"NF do Totem\"] ? Number(String(item[\"NF do Totem\"]).trim()) || 0 : 0,\n                Quantidade: item[\"Quantidade\"] ? Number(item[\"Quantidade\"]) || 1 : 1,\n                \"Tipo do Produto\": item[\"Modelo do totem\"] ? String(item[\"Modelo do totem\"]).trim() : \"N/A\",\n                Modelo: item[\"Modelo do totem\"] ? String(item[\"Modelo do totem\"]).trim() : \"N/A\",\n                Cidade: item[\"Cidade\"] ? String(item[\"Cidade\"]).trim() : \"N/A\",\n                Estado: item[\"Estado\"] ? String(item[\"Estado\"]).trim() : \"N/A\",\n                Transportadora: item[\"Transportadora\"] ? String(item[\"Transportadora\"]).trim() : \"N/A\",\n                Cliente: item[\"Raz\\xe3o Social\"] ? String(item[\"Raz\\xe3o Social\"]).trim() : \"N/A\",\n                \"Valor do Produto\": \"N/A\",\n                \"Valor do Transporte\": \"N/A\",\n                \"Comprovante URL\": comprovanteUrl,\n                \"Tempo de Entrega\": tempoEntrega,\n                \"Nome Fantasia\": item[\"Nome Fantasia\"] ? String(item[\"Nome Fantasia\"]).trim() : \"N/A\"\n            };\n            return result;\n        } catch (error) {\n            console.warn(\"❌ Erro ao processar item iFood:\", item, error);\n            return null;\n        }\n    }).filter((item)=>item !== null);\n};\nfunction useSheetDataIfood() {\n    return (0,_tanstack_react_query__WEBPACK_IMPORTED_MODULE_0__.useQuery)({\n        queryKey: [\n            \"sheet-data-ifood\"\n        ],\n        queryFn: async ()=>{\n            try {\n                if (!SHEET_URL_IFOOD) {\n                    throw new Error(\"URL da planilha iFood n\\xe3o configurada\");\n                }\n                console.log(\"\\uD83D\\uDD04 Buscando dados da planilha iFood...\");\n                const exportUrl = SHEET_URL_IFOOD.replace(\"/edit\", \"/export\").replace(\"?usp=sharing\", \"\") + \"?format=csv&gid=541004446\";\n                const response = await fetch(exportUrl, {\n                    headers: {\n                        \"Cache-Control\": \"no-cache\"\n                    }\n                });\n                if (!response.ok) {\n                    throw new Error(\"Erro HTTP iFood: \".concat(response.status));\n                }\n                const csvText = await response.text();\n                if (!csvText || csvText.trim() === \"\") {\n                    throw new Error(\"Planilha iFood vazia\");\n                }\n                const workbook = xlsx__WEBPACK_IMPORTED_MODULE_1__.read(csvText, {\n                    type: \"string\",\n                    raw: true,\n                    cellDates: false,\n                    dateNF: \"dd/mm/yyyy\"\n                });\n                const sheetName = workbook.SheetNames.find((name)=>name.toLowerCase().includes(\"ifood\")) || workbook.SheetNames[0];\n                const worksheet = workbook.Sheets[sheetName];\n                const rawData = xlsx__WEBPACK_IMPORTED_MODULE_1__.utils.sheet_to_json(worksheet, {\n                    raw: true,\n                    defval: \"\",\n                    dateNF: \"dd/mm/yyyy\"\n                });\n                // DEBUG: Mostrar colunas disponíveis\n                if (rawData.length > 0) {\n                    console.log(\"\\uD83D\\uDD0D COLUNAS DISPON\\xcdVEIS:\", Object.keys(rawData[0]));\n                }\n                const cleanData = validateAndCleanDataIfood(rawData);\n                console.log(\"✅ Dados iFood processados:\", cleanData.length, \"registros\");\n                return cleanData;\n            } catch (error) {\n                console.error(\"❌ Erro ao buscar dados iFood:\", error);\n                throw error;\n            }\n        },\n        refetchInterval: 30000,\n        staleTime: 10000,\n        retry: 2\n    });\n}\nfunction useTrackingSearchCPF(query) {\n    const { data: allData, ...rest } = useSheetDataIfood();\n    const trackingData = (allData === null || allData === void 0 ? void 0 : allData.filter((item)=>{\n        if (!item || !query) return false;\n        try {\n            const cnpjItem = item.CNPJ || \"\";\n            const queryClean = String(query).replace(/\\D/g, \"\").trim();\n            if (!queryClean) return false;\n            return cnpjItem === queryClean;\n        } catch (error) {\n            console.warn(\"Erro na busca iFood:\", error);\n            return false;\n        }\n    })) || [];\n    return {\n        data: trackingData,\n        ...rest\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2hvb2tzL3VzZS10cmFja2luZy1jcGYudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OzhHQUVnRDtBQUNwQjtBQUk1QixNQUFNRSxrQkFBa0JDLE9BQU9BLENBQUNDLEdBQUcsQ0FBQ0MsMkJBQTJCLElBQUk7QUErQm5FLFNBQVNDLFVBQVVDLE9BQXdCO0lBQ3pDLElBQUksQ0FBQ0EsV0FBV0EsWUFBWSxTQUFVLE9BQU9BLFlBQVksWUFBWUEsUUFBUUMsSUFBSSxPQUFPLElBQUssT0FBTztJQUVwRyxJQUFJO1FBQ0YsdUNBQXVDO1FBQ3ZDLElBQUksT0FBT0QsWUFBWSxVQUFVO1lBQy9CLHFEQUFxRDtZQUNyRCxNQUFNRSxhQUFhLElBQUlDLEtBQUssTUFBTSxJQUFJLElBQUkseUJBQXlCOztZQUNuRSxNQUFNQyxPQUFPLElBQUlELEtBQUtELFdBQVdHLE9BQU8sS0FBS0wsVUFBVTtZQUN2RCxPQUFPSTtRQUNUO1FBRUEsc0NBQXNDO1FBQ3RDLE1BQU1FLGFBQWFDLE9BQU9QLFNBQVNDLElBQUk7UUFDdkMsTUFBTSxDQUFDTyxLQUFLQyxPQUFPQyxLQUFLLEdBQUdKLFdBQVdLLEtBQUssQ0FBQyxLQUFLQyxHQUFHLENBQUNDO1FBRXJELG9CQUFvQjtRQUNwQixJQUFJLENBQUNMLE9BQU8sQ0FBQ0MsU0FBUyxDQUFDQyxRQUFRRixNQUFNLEtBQUtBLE1BQU0sTUFBTUMsUUFBUSxLQUFLQSxRQUFRLElBQUk7WUFDN0UsT0FBTztRQUNUO1FBRUEsdURBQXVEO1FBQ3ZELE1BQU1LLFNBQVMsSUFBSVgsS0FBS08sTUFBTUQsUUFBUSxHQUFHRCxLQUFLLElBQUksR0FBRyxHQUFHO1FBRXhELHVCQUF1QjtRQUN2QixJQUFJTSxPQUFPQyxPQUFPLE9BQU9QLE9BQ3JCTSxPQUFPRSxRQUFRLE9BQU9QLFFBQVEsS0FDOUJLLE9BQU9HLFdBQVcsT0FBT1AsTUFBTTtZQUNqQyxPQUFPSTtRQUNUO0lBRUYsRUFBRSxPQUFPSSxPQUFPO1FBQ2RD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b0JBQ1JWLFFBQVE7Z0JBQ1Y7Z0JBRVEscUNBQXFDO2dCQUNyQyxJQUFJaEQsUUFBUTJELE1BQU0sR0FBRyxHQUFHO29CQUN0QnBGLFFBQVF1QyxHQUFHLENBQUMsd0NBQTJCRSxPQUFPQyxJQUFJLENBQUNqQixPQUFPLENBQUMsRUFBRTtnQkFDL0Q7Z0JBRUEsTUFBTTRELFlBQVk3RCwwQkFBMEJDO2dCQUM1Q3pCLFFBQVF1QyxHQUFHLENBQUMsOEJBQThCOEMsVUFBVUQsTUFBTSxFQUFFO2dCQUU1RCxPQUFPQztZQUVULEVBQUUsT0FBT3RGLE9BQU87Z0JBQ2RDLFFBQVFELEtBQUssQ0FBQyxpQ0FBaUNBO2dCQUMvQyxNQUFNQTtZQUNSO1FBRUY7UUFDQXVGLGlCQUFpQjtRQUNqQkMsV0FBVztRQUNYQyxPQUFPO0lBQ1Q7QUFDRjtBQUVPLFNBQVNDLHFCQUFxQkMsS0FBYTtJQUNoRCxNQUFNLEVBQUUzRSxNQUFNNEUsT0FBTyxFQUFFLEdBQUdDLE1BQU0sR0FBR25DO0lBRW5DLE1BQU1vQyxlQUFlRixDQUFBQSxvQkFBQUEsOEJBQUFBLFFBQVMvRCxNQUFNLENBQUNDLENBQUFBO1FBQ25DLElBQUksQ0FBQ0EsUUFBUSxDQUFDNkQsT0FBTyxPQUFPO1FBRTVCLElBQUk7WUFDRixNQUFNSSxXQUFXakUsS0FBS3FCLElBQUksSUFBSTtZQUM5QixNQUFNNkMsYUFBYTNHLE9BQU9zRyxPQUFPMUQsT0FBTyxDQUFDLE9BQU8sSUFBSWxELElBQUk7WUFFeEQsSUFBSSxDQUFDaUgsWUFBWSxPQUFPO1lBRXhCLE9BQU9ELGFBQWFDO1FBQ3RCLEVBQUUsT0FBT2hHLE9BQU87WUFDZEMsUUFBUUMsSUFBSSxDQUFDLHdCQUF3QkY7WUFDckMsT0FBTztRQUNUO0lBQ0YsT0FBTSxFQUFFO0lBRVIsT0FBTztRQUNMZ0IsTUFBTThFO1FBQ04sR0FBR0QsSUFBSTtJQUNUO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vaG9va3MvdXNlLXRyYWNraW5nLWNwZi50cz9jYmY3Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50J1xuXG5pbXBvcnQgeyB1c2VRdWVyeSB9IGZyb20gJ0B0YW5zdGFjay9yZWFjdC1xdWVyeSdcbmltcG9ydCAqIGFzIFhMU1ggZnJvbSAneGxzeCdcbmltcG9ydCB7IFRyYWNraW5nRGF0YSB9IGZyb20gJ0AvdHlwZXMvdHJhY2tpbmcnXG5pbXBvcnQgeyBwYXJzZSwgcGFyc2VJU08sIGlzVmFsaWQsIGRpZmZlcmVuY2VJbkRheXMgfSBmcm9tICdkYXRlLWZucydcblxuY29uc3QgU0hFRVRfVVJMX0lGT09EID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfU0hFRVRfVVJMX0lGT09EIHx8ICdodHRwczovL2RvY3MuZ29vZ2xlLmNvbS9zcHJlYWRzaGVldHMvZC8xQThyTkd0MmUwbXhrMTI0bk45c2preXZhZWswTzFrTm1TLVBkOG5hZ2dwTS9lZGl0P3VzcD1zaGFyaW5nJ1xuXG4vLyBJbnRlcmZhY2UgZXNwZWPDrWZpY2EgcGFyYSBpRm9vZFxuZXhwb3J0IGludGVyZmFjZSBUcmFja2luZ0RhdGFJZm9vZCBleHRlbmRzIFRyYWNraW5nRGF0YSB7XG4gICdDb21wcm92YW50ZSBVUkwnPzogc3RyaW5nXG4gICdUZW1wbyBkZSBFbnRyZWdhJz86IG51bWJlciB8IG51bGxcbn1cblxuLy8gSW50ZXJmYWNlIHBhcmEgb3MgZGFkb3MgYnJ1dG9zIGRhIHBsYW5pbGhhXG5pbnRlcmZhY2UgU2hlZXRSb3dJZm9vZCB7XG4gICdTw6puaW9yJz86IHN0cmluZyB8IG51bWJlclxuICAnUWVwdGEnPzogc3RyaW5nIHwgbnVtYmVyXG4gICdDTlBKJz86IHN0cmluZ1xuICAnRGF0YSByZWFsIGRlIFNhw61kYSc/OiBzdHJpbmdcbiAgJ0RhdGEgcmVhbCBkYSBQcmV2aXPDo28gZGUgRW50cmVnYSc/OiBzdHJpbmdcbiAgJ0RhdGEgUmVhbCBkZSBFbnRyZWdhIHRvdGVtIChleGVjdXRhZGEpJz86IHN0cmluZ1xuICAnTkYgZG8gVG90ZW0nPzogc3RyaW5nIHwgbnVtYmVyXG4gICdRdWFudGlkYWRlJz86IHN0cmluZyB8IG51bWJlclxuICAnTW9kZWxvIGRvIHRvdGVtJz86IHN0cmluZ1xuICAnQ2lkYWRlJz86IHN0cmluZ1xuICAnRXN0YWRvJz86IHN0cmluZ1xuICAnVHJhbnNwb3J0YWRvcmEnPzogc3RyaW5nXG4gICdSYXrDo28gU29jaWFsJz86IHN0cmluZ1xuICAnTm9tZSBGYW50YXNpYSc/OiBzdHJpbmdcbiAgJ0NvbXByb3ZhbnRlIGRlIGVudHJlZ2EnPzogc3RyaW5nXG4gICdOw4NPIEVYQ0xVSVInPzogc3RyaW5nXG4gICdOw4NPIEVYQ0xVSVIgJz86IHN0cmluZ1xuICAnTkFPIEVYQ0xVSVInPzogc3RyaW5nXG4gIFtrZXk6IHN0cmluZ106IGFueSAvLyBQYXJhIG91dHJhcyBjb2x1bmFzIG7Do28gbWFwZWFkYXNcbn1cblxuZnVuY3Rpb24gcGFyc2VEYXRlKGRhdGVTdHI6IHN0cmluZyB8IG51bWJlcik6IERhdGUgfCBudWxsIHtcbiAgaWYgKCFkYXRlU3RyIHx8IGRhdGVTdHIgPT09ICdOL0EnIHx8ICh0eXBlb2YgZGF0ZVN0ciA9PT0gJ3N0cmluZycgJiYgZGF0ZVN0ci50cmltKCkgPT09ICcnKSkgcmV0dXJuIG51bGxcblxuICB0cnkge1xuICAgIC8vIFNlIGZvciBuw7ptZXJvIChzZXJpYWwgZGF0ZSBkbyBFeGNlbClcbiAgICBpZiAodHlwZW9mIGRhdGVTdHIgPT09ICdudW1iZXInKSB7XG4gICAgICAvLyBDb252ZXJ0ZSBzZXJpYWwgZGF0ZSBkbyBFeGNlbCBwYXJhIGRhdGEgSmF2YVNjcmlwdFxuICAgICAgY29uc3QgZXhjZWxFcG9jaCA9IG5ldyBEYXRlKDE4OTksIDExLCAzMCkgLy8gMzAgZGUgZGV6ZW1icm8gZGUgMTg5OVxuICAgICAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKGV4Y2VsRXBvY2guZ2V0VGltZSgpICsgZGF0ZVN0ciAqIDg2NDAwMDAwKVxuICAgICAgcmV0dXJuIGRhdGVcbiAgICB9XG5cbiAgICAvLyBTZSBmb3Igc3RyaW5nIG5vIGZvcm1hdG8gZGQvbW0veXl5eVxuICAgIGNvbnN0IGRhdGVTdHJpbmcgPSBTdHJpbmcoZGF0ZVN0cikudHJpbSgpXG4gICAgY29uc3QgW2RheSwgbW9udGgsIHllYXJdID0gZGF0ZVN0cmluZy5zcGxpdCgnLycpLm1hcChOdW1iZXIpXG4gICAgXG4gICAgLy8gVmFsaWRhIG9zIHZhbG9yZXNcbiAgICBpZiAoIWRheSB8fCAhbW9udGggfHwgIXllYXIgfHwgZGF5IDwgMSB8fCBkYXkgPiAzMSB8fCBtb250aCA8IDEgfHwgbW9udGggPiAxMikge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG4gICAgXG4gICAgLy8gQ3JpYSBhIGRhdGEgw6BzIDEyaCBwYXJhIGV2aXRhciBwcm9ibGVtYXMgZGUgdGltZXpvbmVcbiAgICBjb25zdCBwYXJzZWQgPSBuZXcgRGF0ZSh5ZWFyLCBtb250aCAtIDEsIGRheSwgMTIsIDAsIDAsIDApXG4gICAgXG4gICAgLy8gVmVyaWZpY2HDp8OjbyByaWdvcm9zYVxuICAgIGlmIChwYXJzZWQuZ2V0RGF0ZSgpID09PSBkYXkgJiYgXG4gICAgICAgIHBhcnNlZC5nZXRNb250aCgpID09PSBtb250aCAtIDEgJiYgXG4gICAgICAgIHBhcnNlZC5nZXRGdWxsWWVhcigpID09PSB5ZWFyKSB7XG4gICAgICByZXR1cm4gcGFyc2VkXG4gICAgfVxuICAgIFxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUud2FybignRXJybyBhbyBmYXplciBwYXJzZSBkYSBkYXRhOicsIGRhdGVTdHIsIGVycm9yKVxuICB9XG5cbiAgcmV0dXJuIG51bGxcbn1cblxuZnVuY3Rpb24gY2FsY3VsYXRlRGVsaXZlcnlUaW1lKHN0YXJ0RGF0ZTogc3RyaW5nLCBlbmREYXRlPzogc3RyaW5nKTogbnVtYmVyIHwgdW5kZWZpbmVkIHtcbiAgY29uc3Qgc3RhcnQgPSBwYXJzZURhdGUoc3RhcnREYXRlKVxuICBpZiAoIXN0YXJ0KSByZXR1cm4gdW5kZWZpbmVkXG5cbiAgY29uc3QgZW5kID0gZW5kRGF0ZSA/IHBhcnNlRGF0ZShlbmREYXRlKSA6IG5ldyBEYXRlKClcbiAgaWYgKCFlbmQpIHJldHVybiB1bmRlZmluZWRcblxuICAvLyBDYWxjdWxhIGRpZmVyZW7Dp2EgZW0gZGlhcyB1c2FuZG8gaG9yw6FyaW8gbG9jYWxcbiAgY29uc3Qgc3RhcnRNaWRuaWdodCA9IG5ldyBEYXRlKHN0YXJ0LmdldEZ1bGxZZWFyKCksIHN0YXJ0LmdldE1vbnRoKCksIHN0YXJ0LmdldERhdGUoKSkuZ2V0VGltZSgpXG4gIGNvbnN0IGVuZE1pZG5pZ2h0ID0gbmV3IERhdGUoZW5kLmdldEZ1bGxZZWFyKCksIGVuZC5nZXRNb250aCgpLCBlbmQuZ2V0RGF0ZSgpKS5nZXRUaW1lKClcbiAgXG4gIGNvbnN0IGRpZmZUaW1lID0gZW5kTWlkbmlnaHQgLSBzdGFydE1pZG5pZ2h0XG4gIGNvbnN0IGRpZmZEYXlzID0gTWF0aC5mbG9vcihkaWZmVGltZSAvICgxMDAwICogNjAgKiA2MCAqIDI0KSlcblxuICByZXR1cm4gZGlmZkRheXMgPj0gMCA/IGRpZmZEYXlzIDogdW5kZWZpbmVkXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRUcmFja2luZ1N0YXR1cyhkYXRhOiBUcmFja2luZ0RhdGEpIHtcbiAgY29uc3QgdG9kYXkgPSBuZXcgRGF0ZSgpXG4gIGNvbnN0IGRlbGl2ZXJ5RGF0ZSA9IGRhdGFbJ0RhdGEgZGUgRW50cmVnYSddID8gcGFyc2VEYXRlKGRhdGFbJ0RhdGEgZGUgRW50cmVnYSddKSA6IG51bGxcbiAgY29uc3QgZXhwZWN0ZWREYXRlID0gcGFyc2VEYXRlKGRhdGFbJ1ByZXZpc2FvIGRlIEVudHJlZ2EnXSlcblxuICBpZiAoZGVsaXZlcnlEYXRlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXR1czogJ2RlbGl2ZXJlZCcgYXMgY29uc3QsXG4gICAgICBsYWJlbDogJ0VudHJlZ3VlJyxcbiAgICAgIGNvbG9yOiAndGV4dC1ncmVlbi03MDAgZGFyazp0ZXh0LWdyZWVuLTQwMCcsXG4gICAgICBiZ0NvbG9yOiAnYmctZ3JlZW4tMTAwIGRhcms6YmctZ3JlZW4tOTAwLzMwJ1xuICAgIH1cbiAgfVxuXG4gIGlmIChleHBlY3RlZERhdGUgJiYgdG9kYXkgPiBleHBlY3RlZERhdGUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3RhdHVzOiAnZGVsYXllZCcgYXMgY29uc3QsXG4gICAgICBsYWJlbDogJ0F0cmFzYWRvJyxcbiAgICAgIGNvbG9yOiAndGV4dC1yZWQtNzAwIGRhcms6dGV4dC1yZWQtNDAwJyxcbiAgICAgIGJnQ29sb3I6ICdiZy1yZWQtMTAwIGRhcms6YmctcmVkLTkwMC8zMCdcbiAgICB9XG4gIH1cblxuICBjb25zdCBzaGlwcGluZ0RhdGUgPSBwYXJzZURhdGUoZGF0YVsnRGF0YSBkZSBFbnZpbyddKVxuICBpZiAoc2hpcHBpbmdEYXRlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXR1czogJ3NoaXBwZWQnIGFzIGNvbnN0LFxuICAgICAgbGFiZWw6ICdFbSBUcsOibnNpdG8nLFxuICAgICAgY29sb3I6ICd0ZXh0LWJsdWUtNzAwIGRhcms6dGV4dC1ibHVlLTQwMCcsXG4gICAgICBiZ0NvbG9yOiAnYmctYmx1ZS0xMDAgZGFyazpiZy1ibHVlLTkwMC8zMCdcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHN0YXR1czogJ3BlbmRpbmcnIGFzIGNvbnN0LFxuICAgIGxhYmVsOiAnUHJvY2Vzc2FuZG8nLFxuICAgIGNvbG9yOiAndGV4dC15ZWxsb3ctNzAwIGRhcms6dGV4dC15ZWxsb3ctNDAwJyxcbiAgICBiZ0NvbG9yOiAnYmcteWVsbG93LTEwMCBkYXJrOmJnLXllbGxvdy05MDAvMzAnXG4gIH1cbn1cblxuLy8gTWFwZWFtZW50byBFWEFUTyBwYXJhIGEgcGxhbmlsaGEgaUZvb2RcbmNvbnN0IHZhbGlkYXRlQW5kQ2xlYW5EYXRhSWZvb2QgPSAocmF3RGF0YTogYW55W10pOiBUcmFja2luZ0RhdGFJZm9vZFtdID0+IHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KHJhd0RhdGEpKSB7XG4gICAgY29uc29sZS53YXJuKCdEYWRvcyBpRm9vZCBuw6NvIHPDo28gdW0gYXJyYXk6JywgcmF3RGF0YSlcbiAgICByZXR1cm4gW11cbiAgfVxuXG4gIHJldHVybiByYXdEYXRhXG4gICAgLmZpbHRlcigoaXRlbTogYW55KSA9PiB7XG4gICAgICBpZiAoIWl0ZW0gfHwgdHlwZW9mIGl0ZW0gIT09ICdvYmplY3QnKSByZXR1cm4gZmFsc2VcbiAgICAgIGNvbnN0IGhhc0NOUEogPSBpdGVtWydDTlBKJ10gJiYgU3RyaW5nKGl0ZW1bJ0NOUEonXSkudHJpbSgpICE9PSAnJ1xuICAgICAgcmV0dXJuIGhhc0NOUEpcbiAgICB9KVxuICAgIC5tYXAoKGl0ZW06IGFueSkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgY25wakNsZWFuID0gaXRlbVsnQ05QSiddID8gU3RyaW5nKGl0ZW1bJ0NOUEonXSkucmVwbGFjZSgvXFxEL2csICcnKSA6ICcnXG4gICAgICAgIFxuICAgICAgICBjb25zdCBwZWRpZG9RZXB0YSA9IGl0ZW1bJ1FlcHRhJ10gJiYgU3RyaW5nKGl0ZW1bJ1FlcHRhJ10pLnRyaW0oKSAhPT0gJycgXG4gICAgICAgICAgPyBOdW1iZXIoU3RyaW5nKGl0ZW1bJ1FlcHRhJ10pLnRyaW0oKSkgXG4gICAgICAgICAgOiAwXG5cbiAgICAgICAgLy8gQlVTQ0EgQ09NUFJPVkFOVEUgTkEgQ09MVU5BIEJOIChOw4NPIEVYQ0xVSVIpXG4gICAgICAgIGxldCBjb21wcm92YW50ZVVybCA9ICcnXG4gICAgICAgIFxuICAgICAgICAvLyBUZW50YSBkaWZlcmVudGVzIG5vbWVzIHBvc3PDrXZlaXMgcGFyYSBhIGNvbHVuYSBCTlxuICAgICAgICBjb25zdCBwb3NzaXZlaXNOb21lcyA9IFsnTsODTyBFWENMVUlSJywgJ07Dg08gRVhDTFVJUiAnLCAnTkFPIEVYQ0xVSVInXVxuICAgICAgICBcbiAgICAgICAgZm9yIChjb25zdCBub21lQ29sdW5hIG9mIHBvc3NpdmVpc05vbWVzKSB7XG4gICAgICAgICAgaWYgKGl0ZW1bbm9tZUNvbHVuYV0gJiYgU3RyaW5nKGl0ZW1bbm9tZUNvbHVuYV0pLnRyaW0oKS5zdGFydHNXaXRoKCdodHRwJykpIHtcbiAgICAgICAgICAgIGNvbnN0IGxpbmsgPSBTdHJpbmcoaXRlbVtub21lQ29sdW5hXSkudHJpbSgpXG4gICAgICAgICAgICBjb21wcm92YW50ZVVybCA9IGxpbmsucmVwbGFjZSgnL3ZpZXc/JywgJy9wcmV2aWV3PycpXG4gICAgICAgICAgICBjb25zb2xlLmxvZygn4pyFIExpbmsgZG8gY29tcHJvdmFudGUgZW5jb250cmFkbzonLCBjb21wcm92YW50ZVVybClcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBTZSBuw6NvIGVuY29udHJvdSBjb20gb3Mgbm9tZXMgcGFkcsOjbywgYnVzY2EgcXVhbHF1ZXIgY29sdW5hIHF1ZSBjb21lY2UgY29tIFwiTsODT1wiXG4gICAgICAgIGlmICghY29tcHJvdmFudGVVcmwpIHtcbiAgICAgICAgICBjb25zdCBjb2x1bmFzID0gT2JqZWN0LmtleXMoaXRlbSBhcyBvYmplY3QpXG4gICAgICAgICAgY29uc3QgY29sdW5hQk4gPSBjb2x1bmFzLmZpbmQoY29sID0+IGNvbC5zdGFydHNXaXRoKCdOw4NPJykgfHwgY29sLnN0YXJ0c1dpdGgoJ05BTycpKVxuICAgICAgICAgIGlmIChjb2x1bmFCTiAmJiBpdGVtW2NvbHVuYUJOXSAmJiBTdHJpbmcoaXRlbVtjb2x1bmFCTl0pLnRyaW0oKS5zdGFydHNXaXRoKCdodHRwJykpIHtcbiAgICAgICAgICAgIGNvbnN0IGxpbmsgPSBTdHJpbmcoaXRlbVtjb2x1bmFCTl0pLnRyaW0oKVxuICAgICAgICAgICAgY29tcHJvdmFudGVVcmwgPSBsaW5rLnJlcGxhY2UoJy92aWV3PycsICcvcHJldmlldz8nKVxuICAgICAgICAgICAgY29uc29sZS5sb2coJ+KchSBMaW5rIGVuY29udHJhZG8gbmEgY29sdW5hOicsIGNvbHVuYUJOLCBjb21wcm92YW50ZVVybClcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB0ZW1wb0VudHJlZ2EgPSBjYWxjdWxhdGVEZWxpdmVyeVRpbWUoXG4gICAgICAgICAgaXRlbVsnRGF0YSByZWFsIGRlIFNhw61kYSddIHx8ICcnLFxuICAgICAgICAgIGl0ZW1bJ0RhdGEgUmVhbCBkZSBFbnRyZWdhIHRvdGVtIChleGVjdXRhZGEpJ10gfHwgJydcbiAgICAgICAgKVxuXG4gICAgICAgIGNvbnN0IHJlc3VsdDogVHJhY2tpbmdEYXRhSWZvb2QgPSB7XG4gICAgICAgICAgUGVkaWRvOiBwZWRpZG9RZXB0YSxcbiAgICAgICAgICBRRVBUQTogcGVkaWRvUWVwdGEsXG4gICAgICAgICAgQ05QSjogY25wakNsZWFuLFxuICAgICAgICAgICdEYXRhIGRlIEVudmlvJzogaXRlbVsnRGF0YSByZWFsIGRlIFNhw61kYSddID8gU3RyaW5nKGl0ZW1bJ0RhdGEgcmVhbCBkZSBTYcOtZGEnXSkudHJpbSgpIDogJ04vQScsXG4gICAgICAgICAgJ1ByZXZpc2FvIGRlIEVudHJlZ2EnOiBpdGVtWydEYXRhIHJlYWwgZGEgUHJldmlzw6NvIGRlIEVudHJlZ2EnXSA/IFN0cmluZyhpdGVtWydEYXRhIHJlYWwgZGEgUHJldmlzw6NvIGRlIEVudHJlZ2EnXSkudHJpbSgpIDogJ04vQScsXG4gICAgICAgICAgJ0RhdGEgZGUgRW50cmVnYSc6IGl0ZW1bJ0RhdGEgUmVhbCBkZSBFbnRyZWdhIHRvdGVtIChleGVjdXRhZGEpJ10gPyBTdHJpbmcoaXRlbVsnRGF0YSBSZWFsIGRlIEVudHJlZ2EgdG90ZW0gKGV4ZWN1dGFkYSknXSkudHJpbSgpIDogdW5kZWZpbmVkLFxuICAgICAgICAgICdOb3RhIEZpc2NhbCc6IGl0ZW1bJ05GIGRvIFRvdGVtJ10gPyBOdW1iZXIoU3RyaW5nKGl0ZW1bJ05GIGRvIFRvdGVtJ10pLnRyaW0oKSkgfHwgMCA6IDAsXG4gICAgICAgICAgUXVhbnRpZGFkZTogaXRlbVsnUXVhbnRpZGFkZSddID8gTnVtYmVyKGl0ZW1bJ1F1YW50aWRhZGUnXSkgfHwgMSA6IDEsXG4gICAgICAgICAgJ1RpcG8gZG8gUHJvZHV0byc6IGl0ZW1bJ01vZGVsbyBkbyB0b3RlbSddID8gU3RyaW5nKGl0ZW1bJ01vZGVsbyBkbyB0b3RlbSddKS50cmltKCkgOiAnTi9BJyxcbiAgICAgICAgICBNb2RlbG86IGl0ZW1bJ01vZGVsbyBkbyB0b3RlbSddID8gU3RyaW5nKGl0ZW1bJ01vZGVsbyBkbyB0b3RlbSddKS50cmltKCkgOiAnTi9BJyxcbiAgICAgICAgICBDaWRhZGU6IGl0ZW1bJ0NpZGFkZSddID8gU3RyaW5nKGl0ZW1bJ0NpZGFkZSddKS50cmltKCkgOiAnTi9BJyxcbiAgICAgICAgICBFc3RhZG86IGl0ZW1bJ0VzdGFkbyddID8gU3RyaW5nKGl0ZW1bJ0VzdGFkbyddKS50cmltKCkgOiAnTi9BJyxcbiAgICAgICAgICBUcmFuc3BvcnRhZG9yYTogaXRlbVsnVHJhbnNwb3J0YWRvcmEnXSA/IFN0cmluZyhpdGVtWydUcmFuc3BvcnRhZG9yYSddKS50cmltKCkgOiAnTi9BJyxcbiAgICAgICAgICBDbGllbnRlOiBpdGVtWydSYXrDo28gU29jaWFsJ10gPyBTdHJpbmcoaXRlbVsnUmF6w6NvIFNvY2lhbCddKS50cmltKCkgOiAnTi9BJyxcbiAgICAgICAgICAnVmFsb3IgZG8gUHJvZHV0byc6ICdOL0EnLFxuICAgICAgICAgICdWYWxvciBkbyBUcmFuc3BvcnRlJzogJ04vQScsXG4gICAgICAgICAgJ0NvbXByb3ZhbnRlIFVSTCc6IGNvbXByb3ZhbnRlVXJsLFxuICAgICAgICAgICdUZW1wbyBkZSBFbnRyZWdhJzogdGVtcG9FbnRyZWdhLFxuICAgICAgICAgICdOb21lIEZhbnRhc2lhJzogaXRlbVsnTm9tZSBGYW50YXNpYSddID8gU3RyaW5nKGl0ZW1bJ05vbWUgRmFudGFzaWEnXSkudHJpbSgpIDogJ04vQSdcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHRcblxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCfinYwgRXJybyBhbyBwcm9jZXNzYXIgaXRlbSBpRm9vZDonLCBpdGVtLCBlcnJvcilcbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgIH1cbiAgICB9KVxuICAgIC5maWx0ZXIoKGl0ZW0pOiBpdGVtIGlzIFRyYWNraW5nRGF0YUlmb29kID0+IGl0ZW0gIT09IG51bGwpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VTaGVldERhdGFJZm9vZCgpIHtcbiAgcmV0dXJuIHVzZVF1ZXJ5KHtcbiAgICBxdWVyeUtleTogWydzaGVldC1kYXRhLWlmb29kJ10sXG4gICAgcXVlcnlGbjogYXN5bmMgKCk6IFByb21pc2U8VHJhY2tpbmdEYXRhSWZvb2RbXT4gPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKCFTSEVFVF9VUkxfSUZPT0QpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VSTCBkYSBwbGFuaWxoYSBpRm9vZCBuw6NvIGNvbmZpZ3VyYWRhJylcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnNvbGUubG9nKCfwn5SEIEJ1c2NhbmRvIGRhZG9zIGRhIHBsYW5pbGhhIGlGb29kLi4uJylcblxuICAgICAgICBjb25zdCBleHBvcnRVcmwgPSBTSEVFVF9VUkxfSUZPT0RcbiAgICAgICAgICAucmVwbGFjZSgnL2VkaXQnLCAnL2V4cG9ydCcpXG4gICAgICAgICAgLnJlcGxhY2UoJz91c3A9c2hhcmluZycsICcnKVxuICAgICAgICAgICsgJz9mb3JtYXQ9Y3N2JmdpZD01NDEwMDQ0NDYnXG5cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChleHBvcnRVcmwsIHtcbiAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAnQ2FjaGUtQ29udHJvbCc6ICduby1jYWNoZScsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSlcblxuICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvIEhUVFAgaUZvb2Q6ICR7cmVzcG9uc2Uuc3RhdHVzfWApXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjc3ZUZXh0ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpXG5cbiAgICAgICAgaWYgKCFjc3ZUZXh0IHx8IGNzdlRleHQudHJpbSgpID09PSAnJykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUGxhbmlsaGEgaUZvb2QgdmF6aWEnKVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgd29ya2Jvb2sgPSBYTFNYLnJlYWQoY3N2VGV4dCwgeyBcbiAgdHlwZTogJ3N0cmluZycsXG4gIHJhdzogdHJ1ZSwgIC8vIE1VREFOw4dBOiB0cnVlIGFvIGludsOpcyBkZSBmYWxzZVxuICBjZWxsRGF0ZXM6IGZhbHNlLCAgLy8gQURJQ0lPTkU6IG7Do28gY29udmVydGUgcGFyYSBEYXRlIGF1dG9tYXRpY2FtZW50ZVxuICBkYXRlTkY6ICdkZC9tbS95eXl5J1xufSlcblxuY29uc3Qgc2hlZXROYW1lID0gd29ya2Jvb2suU2hlZXROYW1lcy5maW5kKG5hbWUgPT4gXG4gIG5hbWUudG9Mb3dlckNhc2UoKS5pbmNsdWRlcygnaWZvb2QnKVxuKSB8fCB3b3JrYm9vay5TaGVldE5hbWVzWzBdXG5cbmNvbnN0IHdvcmtzaGVldCA9IHdvcmtib29rLlNoZWV0c1tzaGVldE5hbWVdXG5jb25zdCByYXdEYXRhID0gWExTWC51dGlscy5zaGVldF90b19qc29uKHdvcmtzaGVldCwge1xuICByYXc6IHRydWUsICAvLyBNVURBTsOHQTogdHJ1ZSBhbyBpbnbDqXMgZGUgZmFsc2VcbiAgZGVmdmFsOiAnJyxcbiAgZGF0ZU5GOiAnZGQvbW0veXl5eSdcbn0pIGFzIFNoZWV0Um93SWZvb2RbXVxuXG4gICAgICAgIC8vIERFQlVHOiBNb3N0cmFyIGNvbHVuYXMgZGlzcG9uw612ZWlzXG4gICAgICAgIGlmIChyYXdEYXRhLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBjb25zb2xlLmxvZygn8J+UjSBDT0xVTkFTIERJU1BPTsONVkVJUzonLCBPYmplY3Qua2V5cyhyYXdEYXRhWzBdKSlcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNsZWFuRGF0YSA9IHZhbGlkYXRlQW5kQ2xlYW5EYXRhSWZvb2QocmF3RGF0YSlcbiAgICAgICAgY29uc29sZS5sb2coJ+KchSBEYWRvcyBpRm9vZCBwcm9jZXNzYWRvczonLCBjbGVhbkRhdGEubGVuZ3RoLCAncmVnaXN0cm9zJylcblxuICAgICAgICByZXR1cm4gY2xlYW5EYXRhXG5cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBFcnJvIGFvIGJ1c2NhciBkYWRvcyBpRm9vZDonLCBlcnJvcilcbiAgICAgICAgdGhyb3cgZXJyb3JcbiAgICAgIH1cbiAgICAgIFxuICAgIH0sXG4gICAgcmVmZXRjaEludGVydmFsOiAzMDAwMCxcbiAgICBzdGFsZVRpbWU6IDEwMDAwLFxuICAgIHJldHJ5OiAyLFxuICB9KVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlVHJhY2tpbmdTZWFyY2hDUEYocXVlcnk6IHN0cmluZykge1xuICBjb25zdCB7IGRhdGE6IGFsbERhdGEsIC4uLnJlc3QgfSA9IHVzZVNoZWV0RGF0YUlmb29kKClcblxuICBjb25zdCB0cmFja2luZ0RhdGEgPSBhbGxEYXRhPy5maWx0ZXIoaXRlbSA9PiB7XG4gICAgaWYgKCFpdGVtIHx8ICFxdWVyeSkgcmV0dXJuIGZhbHNlXG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgY25wakl0ZW0gPSBpdGVtLkNOUEogfHwgJydcbiAgICAgIGNvbnN0IHF1ZXJ5Q2xlYW4gPSBTdHJpbmcocXVlcnkpLnJlcGxhY2UoL1xcRC9nLCAnJykudHJpbSgpXG5cbiAgICAgIGlmICghcXVlcnlDbGVhbikgcmV0dXJuIGZhbHNlXG5cbiAgICAgIHJldHVybiBjbnBqSXRlbSA9PT0gcXVlcnlDbGVhblxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ0Vycm8gbmEgYnVzY2EgaUZvb2Q6JywgZXJyb3IpXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH0pIHx8IFtdXG5cbiAgcmV0dXJuIHtcbiAgICBkYXRhOiB0cmFja2luZ0RhdGEsXG4gICAgLi4ucmVzdFxuICB9XG59Il0sIm5hbWVzIjpbInVzZVF1ZXJ5IiwiWExTWCIsIlNIRUVUX1VSTF9JRk9PRCIsInByb2Nlc3MiLCJlbnYiLCJORVhUX1BVQkxJQ19TSEVFVF9VUkxfSUZPT0QiLCJwYXJzZURhdGUiLCJkYXRlU3RyIiwidHJpbSIsImV4Y2VsRXBvY2giLCJEYXRlIiwiZGF0ZSIsImdldFRpbWUiLCJkYXRlU3RyaW5nIiwiU3RyaW5nIiwiZGF5IiwibW9udGgiLCJ5ZWFyIiwic3BsaXQiLCJtYXAiLCJOdW1iZXIiLCJwYXJzZWQiLCJnZXREYXRlIiwiZ2V0TW9udGgiLCJnZXRGdWxsWWVhciIsImVycm9yIiwiY29uc29sZSIsIndhcm4iLCJjYWxjdWxhdGVEZWxpdmVyeVRpbWUiLCJzdGFydERhdGUiLCJlbmREYXRlIiwic3RhcnQiLCJ1bmRlZmluZWQiLCJlbmQiLCJzdGFydE1pZG5pZ2h0IiwiZW5kTWlkbmlnaHQiLCJkaWZmVGltZSIsImRpZmZEYXlzIiwiTWF0aCIsImZsb29yIiwiZ2V0VHJhY2tpbmdTdGF0dXMiLCJkYXRhIiwidG9kYXkiLCJkZWxpdmVyeURhdGUiLCJleHBlY3RlZERhdGUiLCJzdGF0dXMiLCJsYWJlbCIsImNvbG9yIiwiYmdDb2xvciIsInNoaXBwaW5nRGF0ZSIsInZhbGlkYXRlQW5kQ2xlYW5EYXRhSWZvb2QiLCJyYXdEYXRhIiwiQXJyYXkiLCJpc0FycmF5IiwiZmlsdGVyIiwiaXRlbSIsImhhc0NOUEoiLCJjbnBqQ2xlYW4iLCJyZXBsYWNlIiwicGVkaWRvUWVwdGEiLCJjb21wcm92YW50ZVVybCIsInBvc3NpdmVpc05vbWVzIiwibm9tZUNvbHVuYSIsInN0YXJ0c1dpdGgiLCJsaW5rIiwibG9nIiwiY29sdW5hcyIsIk9iamVjdCIsImtleXMiLCJjb2x1bmFCTiIsImZpbmQiLCJjb2wiLCJ0ZW1wb0VudHJlZ2EiLCJyZXN1bHQiLCJQZWRpZG8iLCJRRVBUQSIsIkNOUEoiLCJRdWFudGlkYWRlIiwiTW9kZWxvIiwiQ2lkYWRlIiwiRXN0YWRvIiwiVHJhbnNwb3J0YWRvcmEiLCJDbGllbnRlIiwidXNlU2hlZXREYXRhSWZvb2QiLCJxdWVyeUtleSIsInF1ZXJ5Rm4iLCJFcnJvciIsImV4cG9ydFVybCIsInJlc3BvbnNlIiwiZmV0Y2giLCJoZWFkZXJzIiwib2siLCJjc3ZUZXh0IiwidGV4dCIsIndvcmtib29rIiwicmVhZCIsInR5cGUiLCJyYXciLCJjZWxsRGF0ZXMiLCJkYXRlTkYiLCJzaGVldE5hbWUiLCJTaGVldE5hbWVzIiwibmFtZSIsInRvTG93ZXJDYXNlIiwiaW5jbHVkZXMiLCJ3b3Jrc2hlZXQiLCJTaGVldHMiLCJ1dGlscyIsInNoZWV0X3RvX2pzb24iLCJkZWZ2YWwiLCJsZW5ndGgiLCJjbGVhbkRhdGEiLCJyZWZldGNoSW50ZXJ2YWwiLCJzdGFsZVRpbWUiLCJyZXRyeSIsInVzZVRyYWNraW5nU2VhcmNoQ1BGIiwicXVlcnkiLCJhbGxEYXRhIiwicmVzdCIsInRyYWNraW5nRGF0YSIsImNucGpJdGVtIiwicXVlcnlDbGVhbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./hooks/use-tracking-cpf.ts\n"));

/***/ })

});