"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./hooks/use-tracking.ts":
/*!*******************************!*\
  !*** ./hooks/use-tracking.ts ***!
  \*******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   calculateDays: function() { return /* binding */ calculateDays; },\n/* harmony export */   getTrackingStatus: function() { return /* binding */ getTrackingStatus; },\n/* harmony export */   useSheetData: function() { return /* binding */ useSheetData; },\n/* harmony export */   useTrackingSearch: function() { return /* binding */ useTrackingSearch; }\n/* harmony export */ });\n/* harmony import */ var _tanstack_react_query__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tanstack/react-query */ \"(app-pages-browser)/./node_modules/@tanstack/react-query/build/modern/useQuery.js\");\n/* harmony import */ var xlsx__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! xlsx */ \"(app-pages-browser)/./node_modules/xlsx/xlsx.mjs\");\n/* __next_internal_client_entry_do_not_use__ calculateDays,getTrackingStatus,useSheetData,useTrackingSearch auto */ \n\nconst SHEET_URL = \"https://docs.google.com/spreadsheets/d/1A8rNGt2e0mxk124nN9sjkyvaek0O1kNmS-Pd8naggpM/export?format=csv\" || 0;\nfunction parseDate(dateStr) {\n    if (!dateStr || dateStr === \"N/A\" || typeof dateStr === \"string\" && dateStr.trim() === \"\") return null;\n    try {\n        // Se for número (serial date do Excel)\n        if (typeof dateStr === \"number\") {\n            // Converte serial date do Excel para data JavaScript\n            const excelEpoch = new Date(1899, 11, 30) // 30 de dezembro de 1899\n            ;\n            const date = new Date(excelEpoch.getTime() + dateStr * 86400000);\n            return date;\n        }\n        // Se for string no formato dd/mm/yyyy\n        const dateString = String(dateStr).trim();\n        const [day, month, year] = dateString.split(\"/\").map(Number);\n        // Valida os valores\n        if (!day || !month || !year || day < 1 || day > 31 || month < 1 || month > 12) {\n            return null;\n        }\n        // Cria a data às 12h para evitar problemas de timezone\n        const parsed = new Date(year, month - 1, day, 12, 0, 0, 0);\n        // Verificação rigorosa\n        if (parsed.getDate() === day && parsed.getMonth() === month - 1 && parsed.getFullYear() === year) {\n            return parsed;\n        }\n    } catch (error) {\n        console.warn(\"Erro ao fazer parse da data:\", dateStr, error);\n    }\n    return null;\n}\nfunction calculateDays(startDate, endDate) {\n    const start = parseDate(startDate);\n    if (!start) return null;\n    const end = endDate ? parseDate(endDate) : new Date();\n    if (!end) return null;\n    // Calcula diferença em dias usando horário local\n    const startMidnight = new Date(start.getFullYear(), start.getMonth(), start.getDate()).getTime();\n    const endMidnight = new Date(end.getFullYear(), end.getMonth(), end.getDate()).getTime();\n    const diffTime = endMidnight - startMidnight;\n    const diffDays = Math.floor(diffTime / (1000 * 60 * 60 * 24));\n    return diffDays;\n}\nfunction getTrackingStatus(data) {\n    const today = new Date();\n    const deliveryDate = data[\"Data de Entrega\"] ? parseDate(data[\"Data de Entrega\"]) : null;\n    const expectedDate = parseDate(data[\"Previsao de Entrega\"]);\n    if (deliveryDate) {\n        return {\n            status: \"delivered\",\n            label: \"Entregue\",\n            color: \"text-green-700 dark:text-green-400\",\n            bgColor: \"bg-green-100 dark:bg-green-900/30\"\n        };\n    }\n    if (expectedDate && today > expectedDate) {\n        return {\n            status: \"delayed\",\n            label: \"Atrasado\",\n            color: \"text-red-700 dark:text-red-400\",\n            bgColor: \"bg-red-100 dark:bg-red-900/30\"\n        };\n    }\n    const shippingDate = parseDate(data[\"Data de Envio\"]);\n    if (shippingDate) {\n        return {\n            status: \"shipped\",\n            label: \"Em Tr\\xe2nsito\",\n            color: \"text-blue-700 dark:text-blue-400\",\n            bgColor: \"bg-blue-100 dark:bg-blue-900/30\"\n        };\n    }\n    return {\n        status: \"pending\",\n        label: \"Processando\",\n        color: \"text-yellow-700 dark:text-yellow-400\",\n        bgColor: \"bg-yellow-100 dark:bg-yellow-900/30\"\n    };\n}\n// VALIDAÇÃO REFORÇADA - evita erros nas linhas\nconst validateAndCleanData = (rawData)=>{\n    if (!Array.isArray(rawData)) {\n        return [];\n    }\n    return rawData.filter((item)=>{\n        if (!item || typeof item !== \"object\") return false;\n        return item[\"S\\xeanior\"] || item[\"QEPTA\"] || item[\"NF.\"];\n    }).map((item)=>{\n        try {\n            const pedidoSenior = item[\"S\\xeanior\"] && String(item[\"S\\xeanior\"]).trim() !== \"\" ? Number(String(item[\"S\\xeanior\"]).trim()) : 0;\n            const pedidoQepta = item[\"QEPTA\"] && String(item[\"QEPTA\"]).trim() !== \"\" ? Number(String(item[\"QEPTA\"]).trim()) : 0;\n            const pedidoFinal = pedidoSenior || pedidoQepta;\n            return {\n                Pedido: pedidoFinal,\n                QEPTA: pedidoQepta,\n                \"Data de Envio\": item[\"Data de Envio\"] ? String(item[\"Data de Envio\"]).trim() : \"N/A\",\n                \"Previsao de Entrega\": item[\"Prev. Entrega\"] ? String(item[\"Prev. Entrega\"]).trim() : \"N/A\",\n                \"Data de Entrega\": item[\"Data Entrega\"] ? String(item[\"Data Entrega\"]).trim() : undefined,\n                \"Nota Fiscal\": item[\"NF.\"] ? Number(String(item[\"NF.\"]).trim()) || 0 : 0,\n                Cidade: item[\"Cidade\"] ? String(item[\"Cidade\"]).trim() : \"N/A\",\n                Estado: item[\"UF\"] ? String(item[\"UF\"]).trim() : \"N/A\",\n                Transportadora: item[\"Transportadora\"] ? String(item[\"Transportadora\"]).trim() : \"N/A\",\n                \"Valor do Produto\": item[\"Valor NFe\"] ? String(item[\"Valor NFe\"]).trim() : \"R$ 0,00\",\n                Quantidade: item[\"Quantidade\"] ? Number(item[\"Quantidade\"]) || 1 : 1,\n                \"Tipo do Produto\": item[\"Material\"] ? String(item[\"Material\"]).trim() : \"N/A\",\n                Modelo: item[\"MODELO\"] ? String(item[\"MODELO\"]).trim() : \"N/A\",\n                Cliente: item[\"Cliente\"] ? String(item[\"Cliente\"]).trim() : \"N/A\"\n            };\n        } catch (e) {\n            return null;\n        }\n    }).filter(Boolean);\n};\nfunction useSheetData() {\n    return (0,_tanstack_react_query__WEBPACK_IMPORTED_MODULE_0__.useQuery)({\n        queryKey: [\n            \"sheet-data\"\n        ],\n        queryFn: async ()=>{\n            try {\n                if (!SHEET_URL) {\n                    throw new Error(\"URL da planilha n\\xe3o configurada\");\n                }\n                const response = await fetch(SHEET_URL, {\n                    headers: {\n                        \"Cache-Control\": \"no-cache\"\n                    }\n                });\n                if (!response.ok) {\n                    throw new Error(\"Erro HTTP: \".concat(response.status));\n                }\n                const csvText = await response.text();\n                if (!csvText || csvText.trim() === \"\") {\n                    throw new Error(\"Planilha vazia\");\n                }\n                const workbook = xlsx__WEBPACK_IMPORTED_MODULE_1__.read(csvText, {\n                    type: \"string\",\n                    raw: true,\n                    cellDates: false,\n                    dateNF: \"dd/mm/yyyy\"\n                });\n                const sheetName = workbook.SheetNames[0];\n                if (!sheetName) {\n                    throw new Error(\"Nenhuma aba encontrada\");\n                }\n                const worksheet = workbook.Sheets[sheetName];\n                const rawData = xlsx__WEBPACK_IMPORTED_MODULE_1__.utils.sheet_to_json(worksheet, {\n                    raw: true,\n                    defval: \"\",\n                    dateNF: \"dd/mm/yyyy\"\n                });\n                if (!rawData || rawData.length === 0) {\n                    throw new Error(\"Nenhum dado encontrado\");\n                }\n                return validateAndCleanData(rawData);\n            } catch (error) {\n                console.error(\"Erro ao buscar dados:\", error);\n                throw error;\n            }\n        },\n        refetchInterval: 30000,\n        staleTime: 10000,\n        retry: 2\n    });\n}\nfunction useTrackingSearch(query) {\n    const { data: allData, ...rest } = useSheetData();\n    const trackingData = (allData === null || allData === void 0 ? void 0 : allData.find((item)=>{\n        if (!item || !query) return false;\n        try {\n            const pedidoSenior = String(item.Pedido || \"\").trim();\n            const pedidoQepta = String(item.QEPTA || \"\").trim();\n            const notaFiscal = String(item[\"Nota Fiscal\"] || \"\").trim();\n            const queryTrimmed = String(query).trim();\n            if (!queryTrimmed) return false;\n            return pedidoSenior === queryTrimmed || pedidoQepta === queryTrimmed || notaFiscal === queryTrimmed;\n        } catch (e) {\n            return false;\n        }\n    })) || null;\n    return {\n        data: trackingData,\n        ...rest\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2hvb2tzL3VzZS10cmFja2luZy50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7b0hBRWdEO0FBQ3BCO0FBRzVCLE1BQU1FLFlBQVlDLHVHQUFpQyxJQUFJO0FBRXZELFNBQVNHLFVBQVVDLE9BQXdCO0lBQ3pDLElBQUksQ0FBQ0EsV0FBV0EsWUFBWSxTQUFVLE9BQU9BLFlBQVksWUFBWUEsUUFBUUMsSUFBSSxPQUFPLElBQUssT0FBTztJQUVwRyxJQUFJO1FBQ0YsdUNBQXVDO1FBQ3ZDLElBQUksT0FBT0QsWUFBWSxVQUFVO1lBQy9CLHFEQUFxRDtZQUNyRCxNQUFNRSxhQUFhLElBQUlDLEtBQUssTUFBTSxJQUFJLElBQUkseUJBQXlCOztZQUNuRSxNQUFNQyxPQUFPLElBQUlELEtBQUtELFdBQVdHLE9BQU8sS0FBS0wsVUFBVTtZQUN2RCxPQUFPSTtRQUNUO1FBRUEsc0NBQXNDO1FBQ3RDLE1BQU1FLGFBQWFDLE9BQU9QLFNBQVNDLElBQUk7UUFDdkMsTUFBTSxDQUFDTyxLQUFLQyxPQUFPQyxLQUFLLEdBQUdKLFdBQVdLLEtBQUssQ0FBQyxLQUFLQyxHQUFHLENBQUNDO1FBRXJELG9CQUFvQjtRQUNwQixJQUFJLENBQUNMLE9BQU8sQ0FBQ0MsU0FBUyxDQUFDQyxRQUFRRixNQUFNLEtBQUtBLE1BQU0sTUFBTUMsUUFBUSxLQUFLQSxRQUFRLElBQUk7WUFDN0UsT0FBTztRQUNUO1FBRUEsdURBQXVEO1FBQ3ZELE1BQU1LLFNBQVMsSUFBSVgsS0FBS08sTUFBTUQsUUFBUSxHQUFHRCxLQUFLLElBQUksR0FBRyxHQUFHO1FBRXhELHVCQUF1QjtRQUN2QixJQUFJTSxPQUFPQyxPQUFPLE9BQU9QLE9BQ3JCTSxPQUFPRSxRQUFRLE9BQU9QLFFBQVEsS0FDOUJLLE9BQU9HLFdBQVcsT0FBT1AsTUFBTTtZQUNqQyxPQUFPSTtRQUNUO0lBRUYsRUFBRSxPQUFPSSxPQUFPO1FBQ2RDLFFBQVFDLElBQUksQ0FBQyxnQ0FBZ0NwQixTQUFT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TXlELE9BQU8sRUFBRSxHQUFHQyxNQUFNLEdBQUc5QjtJQUVuQyxNQUFNK0IsZUFBZUYsQ0FBQUEsb0JBQUFBLDhCQUFBQSxRQUFTRyxJQUFJLENBQUM5QyxDQUFBQTtRQUNqQyxJQUFJLENBQUNBLFFBQVEsQ0FBQzBDLE9BQU8sT0FBTztRQUU1QixJQUFJO1lBQ0YsTUFBTXpDLGVBQWV6QyxPQUFPd0MsS0FBS0ksTUFBTSxJQUFJLElBQUlsRCxJQUFJO1lBQ25ELE1BQU1nRCxjQUFjMUMsT0FBT3dDLEtBQUtLLEtBQUssSUFBSSxJQUFJbkQsSUFBSTtZQUNqRCxNQUFNNkYsYUFBYXZGLE9BQU93QyxJQUFJLENBQUMsY0FBYyxJQUFJLElBQUk5QyxJQUFJO1lBQ3pELE1BQU04RixlQUFleEYsT0FBT2tGLE9BQU94RixJQUFJO1lBRXZDLElBQUksQ0FBQzhGLGNBQWMsT0FBTztZQUUxQixPQUFPL0MsaUJBQWlCK0MsZ0JBQ2pCOUMsZ0JBQWdCOEMsZ0JBQ2hCRCxlQUFlQztRQUV4QixFQUFFLFVBQU07WUFDTixPQUFPO1FBQ1Q7SUFDRixPQUFNO0lBRU4sT0FBTztRQUNMOUQsTUFBTTJEO1FBQ04sR0FBR0QsSUFBSTtJQUNUO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vaG9va3MvdXNlLXRyYWNraW5nLnRzP2IwMGEiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnXG5cbmltcG9ydCB7IHVzZVF1ZXJ5IH0gZnJvbSAnQHRhbnN0YWNrL3JlYWN0LXF1ZXJ5J1xuaW1wb3J0ICogYXMgWExTWCBmcm9tICd4bHN4J1xuaW1wb3J0IHsgVHJhY2tpbmdEYXRhIH0gZnJvbSAnQC90eXBlcy90cmFja2luZydcblxuY29uc3QgU0hFRVRfVVJMID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfU0hFRVRfVVJMIHx8ICcnXG5cbmZ1bmN0aW9uIHBhcnNlRGF0ZShkYXRlU3RyOiBzdHJpbmcgfCBudW1iZXIpOiBEYXRlIHwgbnVsbCB7XG4gIGlmICghZGF0ZVN0ciB8fCBkYXRlU3RyID09PSAnTi9BJyB8fCAodHlwZW9mIGRhdGVTdHIgPT09ICdzdHJpbmcnICYmIGRhdGVTdHIudHJpbSgpID09PSAnJykpIHJldHVybiBudWxsXG5cbiAgdHJ5IHtcbiAgICAvLyBTZSBmb3IgbsO6bWVybyAoc2VyaWFsIGRhdGUgZG8gRXhjZWwpXG4gICAgaWYgKHR5cGVvZiBkYXRlU3RyID09PSAnbnVtYmVyJykge1xuICAgICAgLy8gQ29udmVydGUgc2VyaWFsIGRhdGUgZG8gRXhjZWwgcGFyYSBkYXRhIEphdmFTY3JpcHRcbiAgICAgIGNvbnN0IGV4Y2VsRXBvY2ggPSBuZXcgRGF0ZSgxODk5LCAxMSwgMzApIC8vIDMwIGRlIGRlemVtYnJvIGRlIDE4OTlcbiAgICAgIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZShleGNlbEVwb2NoLmdldFRpbWUoKSArIGRhdGVTdHIgKiA4NjQwMDAwMClcbiAgICAgIHJldHVybiBkYXRlXG4gICAgfVxuXG4gICAgLy8gU2UgZm9yIHN0cmluZyBubyBmb3JtYXRvIGRkL21tL3l5eXlcbiAgICBjb25zdCBkYXRlU3RyaW5nID0gU3RyaW5nKGRhdGVTdHIpLnRyaW0oKVxuICAgIGNvbnN0IFtkYXksIG1vbnRoLCB5ZWFyXSA9IGRhdGVTdHJpbmcuc3BsaXQoJy8nKS5tYXAoTnVtYmVyKVxuICAgIFxuICAgIC8vIFZhbGlkYSBvcyB2YWxvcmVzXG4gICAgaWYgKCFkYXkgfHwgIW1vbnRoIHx8ICF5ZWFyIHx8IGRheSA8IDEgfHwgZGF5ID4gMzEgfHwgbW9udGggPCAxIHx8IG1vbnRoID4gMTIpIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuICAgIFxuICAgIC8vIENyaWEgYSBkYXRhIMOgcyAxMmggcGFyYSBldml0YXIgcHJvYmxlbWFzIGRlIHRpbWV6b25lXG4gICAgY29uc3QgcGFyc2VkID0gbmV3IERhdGUoeWVhciwgbW9udGggLSAxLCBkYXksIDEyLCAwLCAwLCAwKVxuICAgIFxuICAgIC8vIFZlcmlmaWNhw6fDo28gcmlnb3Jvc2FcbiAgICBpZiAocGFyc2VkLmdldERhdGUoKSA9PT0gZGF5ICYmIFxuICAgICAgICBwYXJzZWQuZ2V0TW9udGgoKSA9PT0gbW9udGggLSAxICYmIFxuICAgICAgICBwYXJzZWQuZ2V0RnVsbFllYXIoKSA9PT0geWVhcikge1xuICAgICAgcmV0dXJuIHBhcnNlZFxuICAgIH1cbiAgICBcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLndhcm4oJ0Vycm8gYW8gZmF6ZXIgcGFyc2UgZGEgZGF0YTonLCBkYXRlU3RyLCBlcnJvcilcbiAgfVxuXG4gIHJldHVybiBudWxsXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjYWxjdWxhdGVEYXlzKHN0YXJ0RGF0ZTogc3RyaW5nLCBlbmREYXRlPzogc3RyaW5nKTogbnVtYmVyIHwgbnVsbCB7XG4gIGNvbnN0IHN0YXJ0ID0gcGFyc2VEYXRlKHN0YXJ0RGF0ZSlcbiAgaWYgKCFzdGFydCkgcmV0dXJuIG51bGxcblxuICBjb25zdCBlbmQgPSBlbmREYXRlID8gcGFyc2VEYXRlKGVuZERhdGUpIDogbmV3IERhdGUoKVxuICBpZiAoIWVuZCkgcmV0dXJuIG51bGxcblxuICAvLyBDYWxjdWxhIGRpZmVyZW7Dp2EgZW0gZGlhcyB1c2FuZG8gaG9yw6FyaW8gbG9jYWxcbiAgY29uc3Qgc3RhcnRNaWRuaWdodCA9IG5ldyBEYXRlKHN0YXJ0LmdldEZ1bGxZZWFyKCksIHN0YXJ0LmdldE1vbnRoKCksIHN0YXJ0LmdldERhdGUoKSkuZ2V0VGltZSgpXG4gIGNvbnN0IGVuZE1pZG5pZ2h0ID0gbmV3IERhdGUoZW5kLmdldEZ1bGxZZWFyKCksIGVuZC5nZXRNb250aCgpLCBlbmQuZ2V0RGF0ZSgpKS5nZXRUaW1lKClcbiAgXG4gIGNvbnN0IGRpZmZUaW1lID0gZW5kTWlkbmlnaHQgLSBzdGFydE1pZG5pZ2h0XG4gIGNvbnN0IGRpZmZEYXlzID0gTWF0aC5mbG9vcihkaWZmVGltZSAvICgxMDAwICogNjAgKiA2MCAqIDI0KSlcblxuICByZXR1cm4gZGlmZkRheXNcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFRyYWNraW5nU3RhdHVzKGRhdGE6IFRyYWNraW5nRGF0YSkge1xuICBjb25zdCB0b2RheSA9IG5ldyBEYXRlKClcbiAgY29uc3QgZGVsaXZlcnlEYXRlID0gZGF0YVsnRGF0YSBkZSBFbnRyZWdhJ10gPyBwYXJzZURhdGUoZGF0YVsnRGF0YSBkZSBFbnRyZWdhJ10pIDogbnVsbFxuICBjb25zdCBleHBlY3RlZERhdGUgPSBwYXJzZURhdGUoZGF0YVsnUHJldmlzYW8gZGUgRW50cmVnYSddKVxuXG4gIGlmIChkZWxpdmVyeURhdGUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3RhdHVzOiAnZGVsaXZlcmVkJyBhcyBjb25zdCxcbiAgICAgIGxhYmVsOiAnRW50cmVndWUnLFxuICAgICAgY29sb3I6ICd0ZXh0LWdyZWVuLTcwMCBkYXJrOnRleHQtZ3JlZW4tNDAwJyxcbiAgICAgIGJnQ29sb3I6ICdiZy1ncmVlbi0xMDAgZGFyazpiZy1ncmVlbi05MDAvMzAnXG4gICAgfVxuICB9XG5cbiAgaWYgKGV4cGVjdGVkRGF0ZSAmJiB0b2RheSA+IGV4cGVjdGVkRGF0ZSkge1xuICAgIHJldHVybiB7XG4gICAgICBzdGF0dXM6ICdkZWxheWVkJyBhcyBjb25zdCxcbiAgICAgIGxhYmVsOiAnQXRyYXNhZG8nLFxuICAgICAgY29sb3I6ICd0ZXh0LXJlZC03MDAgZGFyazp0ZXh0LXJlZC00MDAnLFxuICAgICAgYmdDb2xvcjogJ2JnLXJlZC0xMDAgZGFyazpiZy1yZWQtOTAwLzMwJ1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHNoaXBwaW5nRGF0ZSA9IHBhcnNlRGF0ZShkYXRhWydEYXRhIGRlIEVudmlvJ10pXG4gIGlmIChzaGlwcGluZ0RhdGUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3RhdHVzOiAnc2hpcHBlZCcgYXMgY29uc3QsXG4gICAgICBsYWJlbDogJ0VtIFRyw6Juc2l0bycsXG4gICAgICBjb2xvcjogJ3RleHQtYmx1ZS03MDAgZGFyazp0ZXh0LWJsdWUtNDAwJyxcbiAgICAgIGJnQ29sb3I6ICdiZy1ibHVlLTEwMCBkYXJrOmJnLWJsdWUtOTAwLzMwJ1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgc3RhdHVzOiAncGVuZGluZycgYXMgY29uc3QsXG4gICAgbGFiZWw6ICdQcm9jZXNzYW5kbycsXG4gICAgY29sb3I6ICd0ZXh0LXllbGxvdy03MDAgZGFyazp0ZXh0LXllbGxvdy00MDAnLFxuICAgIGJnQ29sb3I6ICdiZy15ZWxsb3ctMTAwIGRhcms6YmcteWVsbG93LTkwMC8zMCdcbiAgfVxufVxuXG4vLyBWQUxJREHDh8ODTyBSRUZPUsOHQURBIC0gZXZpdGEgZXJyb3MgbmFzIGxpbmhhc1xuY29uc3QgdmFsaWRhdGVBbmRDbGVhbkRhdGEgPSAocmF3RGF0YTogYW55W10pOiBUcmFja2luZ0RhdGFbXSA9PiB7XG4gIGlmICghQXJyYXkuaXNBcnJheShyYXdEYXRhKSkge1xuICAgIHJldHVybiBbXVxuICB9XG5cbiAgcmV0dXJuIHJhd0RhdGFcbiAgICAuZmlsdGVyKGl0ZW0gPT4ge1xuICAgICAgaWYgKCFpdGVtIHx8IHR5cGVvZiBpdGVtICE9PSAnb2JqZWN0JykgcmV0dXJuIGZhbHNlXG4gICAgICByZXR1cm4gKGl0ZW1bJ1PDqm5pb3InXSB8fCBpdGVtWydRRVBUQSddIHx8IGl0ZW1bJ05GLiddKVxuICAgIH0pXG4gICAgLm1hcChpdGVtID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHBlZGlkb1NlbmlvciA9IGl0ZW1bJ1PDqm5pb3InXSAmJiBTdHJpbmcoaXRlbVsnU8OqbmlvciddKS50cmltKCkgIT09ICcnIFxuICAgICAgICAgID8gTnVtYmVyKFN0cmluZyhpdGVtWydTw6puaW9yJ10pLnRyaW0oKSkgXG4gICAgICAgICAgOiAwXG4gICAgICAgIFxuICAgICAgICBjb25zdCBwZWRpZG9RZXB0YSA9IGl0ZW1bJ1FFUFRBJ10gJiYgU3RyaW5nKGl0ZW1bJ1FFUFRBJ10pLnRyaW0oKSAhPT0gJycgXG4gICAgICAgICAgPyBOdW1iZXIoU3RyaW5nKGl0ZW1bJ1FFUFRBJ10pLnRyaW0oKSkgXG4gICAgICAgICAgOiAwXG4gICAgICAgIFxuICAgICAgICBjb25zdCBwZWRpZG9GaW5hbCA9IHBlZGlkb1NlbmlvciB8fCBwZWRpZG9RZXB0YVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgUGVkaWRvOiBwZWRpZG9GaW5hbCxcbiAgICAgICAgICBRRVBUQTogcGVkaWRvUWVwdGEsXG4gICAgICAgICAgJ0RhdGEgZGUgRW52aW8nOiBpdGVtWydEYXRhIGRlIEVudmlvJ10gPyBTdHJpbmcoaXRlbVsnRGF0YSBkZSBFbnZpbyddKS50cmltKCkgOiAnTi9BJyxcbiAgICAgICAgICAnUHJldmlzYW8gZGUgRW50cmVnYSc6IGl0ZW1bJ1ByZXYuIEVudHJlZ2EnXSA/IFN0cmluZyhpdGVtWydQcmV2LiBFbnRyZWdhJ10pLnRyaW0oKSA6ICdOL0EnLFxuICAgICAgICAgICdEYXRhIGRlIEVudHJlZ2EnOiBpdGVtWydEYXRhIEVudHJlZ2EnXSA/IFN0cmluZyhpdGVtWydEYXRhIEVudHJlZ2EnXSkudHJpbSgpIDogdW5kZWZpbmVkLFxuICAgICAgICAgICdOb3RhIEZpc2NhbCc6IGl0ZW1bJ05GLiddID8gTnVtYmVyKFN0cmluZyhpdGVtWydORi4nXSkudHJpbSgpKSB8fCAwIDogMCxcbiAgICAgICAgICBDaWRhZGU6IGl0ZW1bJ0NpZGFkZSddID8gU3RyaW5nKGl0ZW1bJ0NpZGFkZSddKS50cmltKCkgOiAnTi9BJyxcbiAgICAgICAgICBFc3RhZG86IGl0ZW1bJ1VGJ10gPyBTdHJpbmcoaXRlbVsnVUYnXSkudHJpbSgpIDogJ04vQScsXG4gICAgICAgICAgVHJhbnNwb3J0YWRvcmE6IGl0ZW1bJ1RyYW5zcG9ydGFkb3JhJ10gPyBTdHJpbmcoaXRlbVsnVHJhbnNwb3J0YWRvcmEnXSkudHJpbSgpIDogJ04vQScsXG4gICAgICAgICAgJ1ZhbG9yIGRvIFByb2R1dG8nOiBpdGVtWydWYWxvciBORmUnXSA/IFN0cmluZyhpdGVtWydWYWxvciBORmUnXSkudHJpbSgpIDogJ1IkIDAsMDAnLFxuICAgICAgICAgIFF1YW50aWRhZGU6IGl0ZW1bJ1F1YW50aWRhZGUnXSA/IE51bWJlcihpdGVtWydRdWFudGlkYWRlJ10pIHx8IDEgOiAxLFxuICAgICAgICAgICdUaXBvIGRvIFByb2R1dG8nOiBpdGVtWydNYXRlcmlhbCddID8gU3RyaW5nKGl0ZW1bJ01hdGVyaWFsJ10pLnRyaW0oKSA6ICdOL0EnLFxuICAgICAgICAgIE1vZGVsbzogaXRlbVsnTU9ERUxPJ10gPyBTdHJpbmcoaXRlbVsnTU9ERUxPJ10pLnRyaW0oKSA6ICdOL0EnLFxuICAgICAgICAgIENsaWVudGU6IGl0ZW1bJ0NsaWVudGUnXSA/IFN0cmluZyhpdGVtWydDbGllbnRlJ10pLnRyaW0oKSA6ICdOL0EnXG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2gge1xuICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgfVxuICAgIH0pXG4gICAgLmZpbHRlcihCb29sZWFuKSBhcyBUcmFja2luZ0RhdGFbXVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlU2hlZXREYXRhKCkge1xuICByZXR1cm4gdXNlUXVlcnkoe1xuICAgIHF1ZXJ5S2V5OiBbJ3NoZWV0LWRhdGEnXSxcbiAgICBxdWVyeUZuOiBhc3luYyAoKTogUHJvbWlzZTxUcmFja2luZ0RhdGFbXT4gPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKCFTSEVFVF9VUkwpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VSTCBkYSBwbGFuaWxoYSBuw6NvIGNvbmZpZ3VyYWRhJylcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goU0hFRVRfVVJMLCB7XG4gICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgJ0NhY2hlLUNvbnRyb2wnOiAnbm8tY2FjaGUnLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pXG5cbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRXJybyBIVFRQOiAke3Jlc3BvbnNlLnN0YXR1c31gKVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgY3N2VGV4dCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKVxuXG4gICAgICAgIGlmICghY3N2VGV4dCB8fCBjc3ZUZXh0LnRyaW0oKSA9PT0gJycpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BsYW5pbGhhIHZhemlhJylcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHdvcmtib29rID0gWExTWC5yZWFkKGNzdlRleHQsIHsgXG4gICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgcmF3OiB0cnVlLCAgLy8gTVVEQU7Dh0E6IHRydWUgYW8gaW52w6lzIGRlIGZhbHNlXG4gICAgICAgICAgY2VsbERhdGVzOiBmYWxzZSwgIC8vIEFESUNJT05FOiBuw6NvIGNvbnZlcnRlIHBhcmEgRGF0ZSBhdXRvbWF0aWNhbWVudGVcbiAgICAgICAgICBkYXRlTkY6ICdkZC9tbS95eXl5J1xuICAgICAgICB9KVxuXG4gICAgICAgIGNvbnN0IHNoZWV0TmFtZSA9IHdvcmtib29rLlNoZWV0TmFtZXNbMF1cbiAgICAgICAgaWYgKCFzaGVldE5hbWUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05lbmh1bWEgYWJhIGVuY29udHJhZGEnKVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgd29ya3NoZWV0ID0gd29ya2Jvb2suU2hlZXRzW3NoZWV0TmFtZV1cbiAgICAgICAgY29uc3QgcmF3RGF0YSA9IFhMU1gudXRpbHMuc2hlZXRfdG9fanNvbih3b3Jrc2hlZXQsIHtcbiAgICAgICAgICByYXc6IHRydWUsICAvLyBNVURBTsOHQTogdHJ1ZSBhbyBpbnbDqXMgZGUgZmFsc2VcbiAgICAgICAgICBkZWZ2YWw6ICcnLFxuICAgICAgICAgIGRhdGVORjogJ2RkL21tL3l5eXknXG4gICAgICAgIH0pXG5cbiAgICAgICAgaWYgKCFyYXdEYXRhIHx8IHJhd0RhdGEubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOZW5odW0gZGFkbyBlbmNvbnRyYWRvJylcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWxpZGF0ZUFuZENsZWFuRGF0YShyYXdEYXRhKVxuXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvIGFvIGJ1c2NhciBkYWRvczonLCBlcnJvcilcbiAgICAgICAgdGhyb3cgZXJyb3JcbiAgICAgIH1cbiAgICB9LFxuICAgIHJlZmV0Y2hJbnRlcnZhbDogMzAwMDAsXG4gICAgc3RhbGVUaW1lOiAxMDAwMCxcbiAgICByZXRyeTogMixcbiAgfSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZVRyYWNraW5nU2VhcmNoKHF1ZXJ5OiBzdHJpbmcpIHtcbiAgY29uc3QgeyBkYXRhOiBhbGxEYXRhLCAuLi5yZXN0IH0gPSB1c2VTaGVldERhdGEoKVxuXG4gIGNvbnN0IHRyYWNraW5nRGF0YSA9IGFsbERhdGE/LmZpbmQoaXRlbSA9PiB7XG4gICAgaWYgKCFpdGVtIHx8ICFxdWVyeSkgcmV0dXJuIGZhbHNlXG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgcGVkaWRvU2VuaW9yID0gU3RyaW5nKGl0ZW0uUGVkaWRvIHx8ICcnKS50cmltKClcbiAgICAgIGNvbnN0IHBlZGlkb1FlcHRhID0gU3RyaW5nKGl0ZW0uUUVQVEEgfHwgJycpLnRyaW0oKVxuICAgICAgY29uc3Qgbm90YUZpc2NhbCA9IFN0cmluZyhpdGVtWydOb3RhIEZpc2NhbCddIHx8ICcnKS50cmltKClcbiAgICAgIGNvbnN0IHF1ZXJ5VHJpbW1lZCA9IFN0cmluZyhxdWVyeSkudHJpbSgpXG5cbiAgICAgIGlmICghcXVlcnlUcmltbWVkKSByZXR1cm4gZmFsc2VcblxuICAgICAgcmV0dXJuIHBlZGlkb1NlbmlvciA9PT0gcXVlcnlUcmltbWVkIHx8IFxuICAgICAgICAgICAgIHBlZGlkb1FlcHRhID09PSBxdWVyeVRyaW1tZWQgfHxcbiAgICAgICAgICAgICBub3RhRmlzY2FsID09PSBxdWVyeVRyaW1tZWRcblxuICAgIH0gY2F0Y2gge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9KSB8fCBudWxsXG5cbiAgcmV0dXJuIHtcbiAgICBkYXRhOiB0cmFja2luZ0RhdGEsXG4gICAgLi4ucmVzdFxuICB9XG59Il0sIm5hbWVzIjpbInVzZVF1ZXJ5IiwiWExTWCIsIlNIRUVUX1VSTCIsInByb2Nlc3MiLCJlbnYiLCJORVhUX1BVQkxJQ19TSEVFVF9VUkwiLCJwYXJzZURhdGUiLCJkYXRlU3RyIiwidHJpbSIsImV4Y2VsRXBvY2giLCJEYXRlIiwiZGF0ZSIsImdldFRpbWUiLCJkYXRlU3RyaW5nIiwiU3RyaW5nIiwiZGF5IiwibW9udGgiLCJ5ZWFyIiwic3BsaXQiLCJtYXAiLCJOdW1iZXIiLCJwYXJzZWQiLCJnZXREYXRlIiwiZ2V0TW9udGgiLCJnZXRGdWxsWWVhciIsImVycm9yIiwiY29uc29sZSIsIndhcm4iLCJjYWxjdWxhdGVEYXlzIiwic3RhcnREYXRlIiwiZW5kRGF0ZSIsInN0YXJ0IiwiZW5kIiwic3RhcnRNaWRuaWdodCIsImVuZE1pZG5pZ2h0IiwiZGlmZlRpbWUiLCJkaWZmRGF5cyIsIk1hdGgiLCJmbG9vciIsImdldFRyYWNraW5nU3RhdHVzIiwiZGF0YSIsInRvZGF5IiwiZGVsaXZlcnlEYXRlIiwiZXhwZWN0ZWREYXRlIiwic3RhdHVzIiwibGFiZWwiLCJjb2xvciIsImJnQ29sb3IiLCJzaGlwcGluZ0RhdGUiLCJ2YWxpZGF0ZUFuZENsZWFuRGF0YSIsInJhd0RhdGEiLCJBcnJheSIsImlzQXJyYXkiLCJmaWx0ZXIiLCJpdGVtIiwicGVkaWRvU2VuaW9yIiwicGVkaWRvUWVwdGEiLCJwZWRpZG9GaW5hbCIsIlBlZGlkbyIsIlFFUFRBIiwidW5kZWZpbmVkIiwiQ2lkYWRlIiwiRXN0YWRvIiwiVHJhbnNwb3J0YWRvcmEiLCJRdWFudGlkYWRlIiwiTW9kZWxvIiwiQ2xpZW50ZSIsIkJvb2xlYW4iLCJ1c2VTaGVldERhdGEiLCJxdWVyeUtleSIsInF1ZXJ5Rm4iLCJFcnJvciIsInJlc3BvbnNlIiwiZmV0Y2giLCJoZWFkZXJzIiwib2siLCJjc3ZUZXh0IiwidGV4dCIsIndvcmtib29rIiwicmVhZCIsInR5cGUiLCJyYXciLCJjZWxsRGF0ZXMiLCJkYXRlTkYiLCJzaGVldE5hbWUiLCJTaGVldE5hbWVzIiwid29ya3NoZWV0IiwiU2hlZXRzIiwidXRpbHMiLCJzaGVldF90b19qc29uIiwiZGVmdmFsIiwibGVuZ3RoIiwicmVmZXRjaEludGVydmFsIiwic3RhbGVUaW1lIiwicmV0cnkiLCJ1c2VUcmFja2luZ1NlYXJjaCIsInF1ZXJ5IiwiYWxsRGF0YSIsInJlc3QiLCJ0cmFja2luZ0RhdGEiLCJmaW5kIiwibm90YUZpc2NhbCIsInF1ZXJ5VHJpbW1lZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./hooks/use-tracking.ts\n"));

/***/ })

});